// Code generated from ggw.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // ggw
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type ggwParser struct {
	*antlr.BaseParser
}

var GgwParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func ggwParserInit() {
	staticData := &GgwParserStaticData
	staticData.LiteralNames = []string{
		"", "'{'", "'}'", "'return'", "';'", "'break'", "'continue'", "'&&'",
		"'||'", "'<'", "'<='", "'>'", "'>='", "'=='", "'!='", "'+'", "'-'",
		"'*'", "'/'", "'%'", "'['", "']'", "'?'", "':'", "'++'", "'--'", "'+='",
		"'-='", "'*='", "'/='", "'%='", "'('", "')'", "'new'", "'.'", "','",
		"'on'", "'backend'", "'frontend'", "'shared'", "'module'", "'import'",
		"'as'", "'from'", "'='", "'...'", "'@'", "'annotation'", "'public'",
		"'private'", "'protected'", "'let'", "'const'", "'static'", "'WebSockets'",
		"'HTTP'", "'wire'", "'authenticated'", "'func'", "'->'", "'constructor'",
		"'enum'", "'interface'", "'class'", "'if'", "'else if'", "'else'", "'when'",
		"'=>'", "'for'", "'in'", "'while'", "'do'", "'grant'", "'with'", "'revoke'",
		"'all'", "'grant-tree'", "'has'", "'inherits'", "'expect'", "'session'",
		"'int'", "'float'", "'bool'", "'string'", "'none'", "'[]'", "'wire.'",
		"'extends'", "'implements'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "WS", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT",
		"DOC_COMMENT", "INT", "FLOAT", "BOOL", "STRING", "IDENTIFIER",
	}
	staticData.RuleNames = []string{
		"file", "block", "statement", "expression", "logicalExpression", "comparisonExpression",
		"additiveExpression", "multiplicativeExpression", "postfixExpression",
		"postfixOperator", "incrementalExpression", "primaryExpression", "groupedExpression",
		"funcCallExpression", "funcCallChaining", "arrayExpression", "mapExpression",
		"onStatement", "moduleStatemnt", "importStatement", "argument", "argumentList",
		"argumentPassList", "annotation", "annotationList", "annotationArgName",
		"annotationArgument", "annotationDeclaration", "accessModifier", "typeDeclaration",
		"deconstruct", "variableName", "variableKind", "variableDeclaration",
		"variableMultiDeclaration", "variableClassDeclaration", "wireKind",
		"wireDeclaration", "wireAuth", "functionDeclaration", "functionClassDeclaration",
		"anonymousFunctionDeclaration", "constructorHeadDeclaration", "constructorFuncDeclaration",
		"enumDeclaration", "enumProperty", "interfaceDeclaration", "interfaceBodyDeclaration",
		"interfaceProperty", "interfaceFunction", "classDeclaration", "classBodyDeclaration",
		"ifStatement", "whenStatement", "whenCase", "whenCaseBlock", "forStatement",
		"forIncrementExpression", "forInStatement", "whileStatement", "doWhileStatement",
		"grantStatement", "revokeStatement", "grantTree", "grantTreeBody", "grantTreeBranch",
		"grantTreeInheritance", "sessionDeclaration", "sessionBody", "sessionProperty",
		"type", "primitiveType", "arrayType", "mapType", "tupleType", "genericTypeDeclaration",
		"genericDeclaration", "genericUsage", "identifierUsage", "extends",
		"interfaceExtends", "implements",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 99, 1048, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7,
		4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7,
		10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15,
		2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2,
		21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26,
		7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7,
		31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36,
		2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2,
		42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47,
		7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7,
		52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57,
		2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2,
		63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68,
		7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7,
		73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78,
		2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 1, 0, 5, 0, 166, 8, 0, 10, 0,
		12, 0, 169, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 5, 1, 175, 8, 1, 10, 1, 12, 1,
		178, 9, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 207, 8, 2, 1, 2, 3, 2, 210, 8, 2, 1,
		2, 1, 2, 3, 2, 214, 8, 2, 1, 2, 3, 2, 217, 8, 2, 1, 2, 1, 2, 3, 2, 221,
		8, 2, 1, 2, 3, 2, 224, 8, 2, 1, 2, 3, 2, 227, 8, 2, 1, 3, 1, 3, 3, 3, 231,
		8, 3, 1, 4, 1, 4, 1, 4, 5, 4, 236, 8, 4, 10, 4, 12, 4, 239, 9, 4, 1, 5,
		1, 5, 1, 5, 5, 5, 244, 8, 5, 10, 5, 12, 5, 247, 9, 5, 1, 6, 1, 6, 1, 6,
		5, 6, 252, 8, 6, 10, 6, 12, 6, 255, 9, 6, 1, 7, 1, 7, 1, 7, 5, 7, 260,
		8, 7, 10, 7, 12, 7, 263, 9, 7, 1, 8, 1, 8, 5, 8, 267, 8, 8, 10, 8, 12,
		8, 270, 9, 8, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1,
		9, 3, 9, 282, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 3,
		10, 291, 8, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11,
		1, 11, 1, 11, 1, 11, 1, 11, 3, 11, 305, 8, 11, 1, 12, 1, 12, 1, 12, 1,
		12, 1, 13, 1, 13, 1, 13, 3, 13, 314, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13,
		1, 13, 1, 13, 3, 13, 322, 8, 13, 1, 13, 1, 13, 3, 13, 326, 8, 13, 1, 14,
		1, 14, 1, 14, 1, 14, 3, 14, 332, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3,
		14, 338, 8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 5, 15, 344, 8, 15, 10, 15,
		12, 15, 347, 9, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1,
		16, 1, 16, 1, 16, 1, 16, 5, 16, 360, 8, 16, 10, 16, 12, 16, 363, 9, 16,
		1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 3, 18, 373, 8,
		18, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 379, 8, 19, 1, 19, 1, 19, 3, 19,
		383, 8, 19, 1, 20, 1, 20, 3, 20, 387, 8, 20, 1, 20, 1, 20, 3, 20, 391,
		8, 20, 1, 21, 1, 21, 1, 21, 5, 21, 396, 8, 21, 10, 21, 12, 21, 399, 9,
		21, 1, 21, 1, 21, 1, 21, 3, 21, 404, 8, 21, 1, 21, 1, 21, 3, 21, 408, 8,
		21, 1, 22, 1, 22, 1, 22, 5, 22, 413, 8, 22, 10, 22, 12, 22, 416, 9, 22,
		1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23, 5, 23, 424, 8, 23, 10, 23, 12,
		23, 427, 9, 23, 3, 23, 429, 8, 23, 1, 23, 3, 23, 432, 8, 23, 1, 24, 5,
		24, 435, 8, 24, 10, 24, 12, 24, 438, 9, 24, 1, 25, 1, 25, 1, 25, 1, 26,
		3, 26, 444, 8, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1,
		27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 5, 30,
		463, 8, 30, 10, 30, 12, 30, 466, 9, 30, 1, 30, 1, 30, 1, 31, 1, 31, 3,
		31, 472, 8, 31, 1, 32, 3, 32, 475, 8, 32, 1, 32, 1, 32, 3, 32, 479, 8,
		32, 1, 33, 3, 33, 482, 8, 33, 1, 33, 1, 33, 3, 33, 486, 8, 33, 1, 33, 1,
		33, 3, 33, 490, 8, 33, 1, 33, 3, 33, 493, 8, 33, 1, 33, 3, 33, 496, 8,
		33, 1, 34, 3, 34, 499, 8, 34, 1, 34, 1, 34, 1, 34, 5, 34, 504, 8, 34, 10,
		34, 12, 34, 507, 9, 34, 1, 34, 3, 34, 510, 8, 34, 1, 34, 1, 34, 1, 34,
		1, 34, 5, 34, 516, 8, 34, 10, 34, 12, 34, 519, 9, 34, 3, 34, 521, 8, 34,
		1, 34, 3, 34, 524, 8, 34, 1, 34, 3, 34, 527, 8, 34, 1, 35, 3, 35, 530,
		8, 35, 1, 35, 3, 35, 533, 8, 35, 1, 35, 3, 35, 536, 8, 35, 1, 35, 1, 35,
		3, 35, 540, 8, 35, 1, 36, 1, 36, 1, 37, 1, 37, 3, 37, 546, 8, 37, 1, 37,
		3, 37, 549, 8, 37, 1, 37, 3, 37, 552, 8, 37, 1, 38, 1, 38, 3, 38, 556,
		8, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 5, 38, 563, 8, 38, 10, 38, 12,
		38, 566, 9, 38, 1, 38, 3, 38, 569, 8, 38, 1, 38, 3, 38, 572, 8, 38, 1,
		39, 3, 39, 575, 8, 39, 1, 39, 1, 39, 1, 39, 3, 39, 580, 8, 39, 1, 39, 1,
		39, 3, 39, 584, 8, 39, 1, 39, 1, 39, 3, 39, 588, 8, 39, 1, 39, 3, 39, 591,
		8, 39, 1, 39, 1, 39, 1, 40, 3, 40, 596, 8, 40, 1, 40, 3, 40, 599, 8, 40,
		1, 40, 3, 40, 602, 8, 40, 1, 40, 1, 40, 1, 40, 3, 40, 607, 8, 40, 1, 40,
		1, 40, 3, 40, 611, 8, 40, 1, 40, 1, 40, 3, 40, 615, 8, 40, 1, 40, 1, 40,
		1, 41, 1, 41, 3, 41, 621, 8, 41, 1, 41, 1, 41, 3, 41, 625, 8, 41, 1, 41,
		1, 41, 1, 41, 3, 41, 630, 8, 41, 1, 42, 1, 42, 3, 42, 634, 8, 42, 1, 42,
		1, 42, 1, 43, 3, 43, 639, 8, 43, 1, 43, 3, 43, 642, 8, 43, 1, 43, 1, 43,
		1, 43, 1, 43, 1, 44, 1, 44, 3, 44, 650, 8, 44, 1, 44, 1, 44, 1, 44, 1,
		44, 1, 44, 1, 44, 1, 44, 5, 44, 659, 8, 44, 10, 44, 12, 44, 662, 9, 44,
		1, 44, 5, 44, 665, 8, 44, 10, 44, 12, 44, 668, 9, 44, 1, 44, 1, 44, 1,
		45, 1, 45, 1, 45, 1, 45, 3, 45, 676, 8, 45, 1, 45, 3, 45, 679, 8, 45, 1,
		46, 3, 46, 682, 8, 46, 1, 46, 1, 46, 1, 46, 3, 46, 687, 8, 46, 1, 46, 3,
		46, 690, 8, 46, 1, 46, 1, 46, 5, 46, 694, 8, 46, 10, 46, 12, 46, 697, 9,
		46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 703, 8, 47, 1, 48, 3, 48, 706, 8,
		48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 3, 49, 713, 8, 49, 1, 49, 1, 49,
		3, 49, 717, 8, 49, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 3, 50, 724, 8, 50,
		1, 50, 1, 50, 1, 50, 3, 50, 729, 8, 50, 1, 50, 3, 50, 732, 8, 50, 1, 50,
		3, 50, 735, 8, 50, 1, 50, 3, 50, 738, 8, 50, 1, 50, 3, 50, 741, 8, 50,
		1, 50, 1, 50, 5, 50, 745, 8, 50, 10, 50, 12, 50, 748, 9, 50, 1, 50, 1,
		50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 3, 51, 758, 8, 51, 1, 52,
		1, 52, 3, 52, 762, 8, 52, 1, 52, 1, 52, 3, 52, 766, 8, 52, 1, 52, 1, 52,
		1, 52, 3, 52, 771, 8, 52, 1, 52, 1, 52, 3, 52, 775, 8, 52, 1, 52, 1, 52,
		5, 52, 779, 8, 52, 10, 52, 12, 52, 782, 9, 52, 1, 52, 1, 52, 3, 52, 786,
		8, 52, 1, 53, 1, 53, 3, 53, 790, 8, 53, 1, 53, 1, 53, 3, 53, 794, 8, 53,
		1, 53, 1, 53, 5, 53, 798, 8, 53, 10, 53, 12, 53, 801, 9, 53, 1, 53, 1,
		53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55,
		5, 55, 815, 8, 55, 10, 55, 12, 55, 818, 9, 55, 1, 55, 1, 55, 3, 55, 822,
		8, 55, 1, 56, 1, 56, 3, 56, 826, 8, 56, 1, 56, 3, 56, 829, 8, 56, 1, 56,
		1, 56, 3, 56, 833, 8, 56, 1, 56, 1, 56, 3, 56, 837, 8, 56, 1, 56, 3, 56,
		840, 8, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 3, 57, 851, 8, 57, 1, 58, 1, 58, 3, 58, 855, 8, 58, 1, 58, 1, 58, 1,
		58, 5, 58, 860, 8, 58, 10, 58, 12, 58, 863, 9, 58, 1, 58, 1, 58, 1, 58,
		3, 58, 868, 8, 58, 1, 58, 1, 58, 1, 59, 1, 59, 3, 59, 874, 8, 59, 1, 59,
		1, 59, 3, 59, 878, 8, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 3,
		60, 886, 8, 60, 1, 60, 1, 60, 3, 60, 890, 8, 60, 1, 61, 1, 61, 1, 61, 1,
		61, 1, 61, 1, 61, 1, 61, 5, 61, 899, 8, 61, 10, 61, 12, 61, 902, 9, 61,
		1, 61, 3, 61, 905, 8, 61, 3, 61, 907, 8, 61, 1, 62, 1, 62, 1, 62, 3, 62,
		912, 8, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 5, 64, 920, 8, 64,
		10, 64, 12, 64, 923, 9, 64, 1, 65, 1, 65, 3, 65, 927, 8, 65, 1, 65, 1,
		65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 5, 66, 936, 8, 66, 10, 66, 12, 66,
		939, 9, 66, 1, 66, 1, 66, 3, 66, 943, 8, 66, 1, 67, 1, 67, 3, 67, 947,
		8, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 68, 5, 68, 954, 8, 68, 10, 68, 12,
		68, 957, 9, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70,
		1, 70, 3, 70, 968, 8, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 73, 1,
		73, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 74, 5, 74, 984, 8, 74,
		10, 74, 12, 74, 987, 9, 74, 1, 74, 1, 74, 1, 75, 1, 75, 3, 75, 993, 8,
		75, 1, 75, 3, 75, 996, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 5, 76, 1002,
		8, 76, 10, 76, 12, 76, 1005, 9, 76, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77,
		1, 77, 1, 78, 3, 78, 1014, 8, 78, 1, 78, 1, 78, 3, 78, 1018, 8, 78, 1,
		78, 1, 78, 5, 78, 1022, 8, 78, 10, 78, 12, 78, 1025, 9, 78, 1, 79, 1, 79,
		1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 5, 80, 1034, 8, 80, 10, 80, 12, 80,
		1037, 9, 80, 1, 81, 1, 81, 1, 81, 1, 81, 5, 81, 1043, 8, 81, 10, 81, 12,
		81, 1046, 9, 81, 1, 81, 0, 0, 82, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
		58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
		94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
		154, 156, 158, 160, 162, 0, 12, 1, 0, 7, 8, 1, 0, 9, 14, 1, 0, 15, 16,
		1, 0, 17, 19, 1, 0, 24, 25, 1, 0, 26, 30, 1, 0, 37, 39, 1, 0, 95, 99, 1,
		0, 48, 50, 1, 0, 54, 55, 1, 0, 26, 27, 1, 0, 82, 86, 1158, 0, 167, 1, 0,
		0, 0, 2, 172, 1, 0, 0, 0, 4, 226, 1, 0, 0, 0, 6, 230, 1, 0, 0, 0, 8, 232,
		1, 0, 0, 0, 10, 240, 1, 0, 0, 0, 12, 248, 1, 0, 0, 0, 14, 256, 1, 0, 0,
		0, 16, 264, 1, 0, 0, 0, 18, 281, 1, 0, 0, 0, 20, 290, 1, 0, 0, 0, 22, 304,
		1, 0, 0, 0, 24, 306, 1, 0, 0, 0, 26, 325, 1, 0, 0, 0, 28, 337, 1, 0, 0,
		0, 30, 339, 1, 0, 0, 0, 32, 350, 1, 0, 0, 0, 34, 366, 1, 0, 0, 0, 36, 369,
		1, 0, 0, 0, 38, 374, 1, 0, 0, 0, 40, 384, 1, 0, 0, 0, 42, 407, 1, 0, 0,
		0, 44, 409, 1, 0, 0, 0, 46, 417, 1, 0, 0, 0, 48, 436, 1, 0, 0, 0, 50, 439,
		1, 0, 0, 0, 52, 443, 1, 0, 0, 0, 54, 447, 1, 0, 0, 0, 56, 453, 1, 0, 0,
		0, 58, 455, 1, 0, 0, 0, 60, 458, 1, 0, 0, 0, 62, 471, 1, 0, 0, 0, 64, 478,
		1, 0, 0, 0, 66, 481, 1, 0, 0, 0, 68, 498, 1, 0, 0, 0, 70, 529, 1, 0, 0,
		0, 72, 541, 1, 0, 0, 0, 74, 543, 1, 0, 0, 0, 76, 553, 1, 0, 0, 0, 78, 574,
		1, 0, 0, 0, 80, 595, 1, 0, 0, 0, 82, 618, 1, 0, 0, 0, 84, 631, 1, 0, 0,
		0, 86, 638, 1, 0, 0, 0, 88, 647, 1, 0, 0, 0, 90, 671, 1, 0, 0, 0, 92, 681,
		1, 0, 0, 0, 94, 702, 1, 0, 0, 0, 96, 705, 1, 0, 0, 0, 98, 710, 1, 0, 0,
		0, 100, 721, 1, 0, 0, 0, 102, 757, 1, 0, 0, 0, 104, 759, 1, 0, 0, 0, 106,
		787, 1, 0, 0, 0, 108, 808, 1, 0, 0, 0, 110, 821, 1, 0, 0, 0, 112, 823,
		1, 0, 0, 0, 114, 850, 1, 0, 0, 0, 116, 852, 1, 0, 0, 0, 118, 871, 1, 0,
		0, 0, 120, 881, 1, 0, 0, 0, 122, 891, 1, 0, 0, 0, 124, 908, 1, 0, 0, 0,
		126, 913, 1, 0, 0, 0, 128, 921, 1, 0, 0, 0, 130, 924, 1, 0, 0, 0, 132,
		931, 1, 0, 0, 0, 134, 944, 1, 0, 0, 0, 136, 955, 1, 0, 0, 0, 138, 958,
		1, 0, 0, 0, 140, 967, 1, 0, 0, 0, 142, 969, 1, 0, 0, 0, 144, 971, 1, 0,
		0, 0, 146, 974, 1, 0, 0, 0, 148, 979, 1, 0, 0, 0, 150, 990, 1, 0, 0, 0,
		152, 997, 1, 0, 0, 0, 154, 1008, 1, 0, 0, 0, 156, 1013, 1, 0, 0, 0, 158,
		1026, 1, 0, 0, 0, 160, 1029, 1, 0, 0, 0, 162, 1038, 1, 0, 0, 0, 164, 166,
		3, 4, 2, 0, 165, 164, 1, 0, 0, 0, 166, 169, 1, 0, 0, 0, 167, 165, 1, 0,
		0, 0, 167, 168, 1, 0, 0, 0, 168, 170, 1, 0, 0, 0, 169, 167, 1, 0, 0, 0,
		170, 171, 5, 0, 0, 1, 171, 1, 1, 0, 0, 0, 172, 176, 5, 1, 0, 0, 173, 175,
		3, 4, 2, 0, 174, 173, 1, 0, 0, 0, 175, 178, 1, 0, 0, 0, 176, 174, 1, 0,
		0, 0, 176, 177, 1, 0, 0, 0, 177, 179, 1, 0, 0, 0, 178, 176, 1, 0, 0, 0,
		179, 180, 5, 2, 0, 0, 180, 3, 1, 0, 0, 0, 181, 227, 3, 34, 17, 0, 182,
		227, 3, 36, 18, 0, 183, 227, 3, 38, 19, 0, 184, 227, 3, 66, 33, 0, 185,
		227, 3, 68, 34, 0, 186, 227, 3, 78, 39, 0, 187, 227, 3, 86, 43, 0, 188,
		227, 3, 54, 27, 0, 189, 227, 3, 88, 44, 0, 190, 227, 3, 92, 46, 0, 191,
		227, 3, 100, 50, 0, 192, 227, 3, 104, 52, 0, 193, 227, 3, 112, 56, 0, 194,
		227, 3, 116, 58, 0, 195, 227, 3, 118, 59, 0, 196, 227, 3, 120, 60, 0, 197,
		227, 3, 106, 53, 0, 198, 227, 3, 26, 13, 0, 199, 227, 3, 20, 10, 0, 200,
		227, 3, 122, 61, 0, 201, 227, 3, 124, 62, 0, 202, 227, 3, 126, 63, 0, 203,
		227, 3, 134, 67, 0, 204, 206, 5, 3, 0, 0, 205, 207, 3, 6, 3, 0, 206, 205,
		1, 0, 0, 0, 206, 207, 1, 0, 0, 0, 207, 209, 1, 0, 0, 0, 208, 210, 5, 4,
		0, 0, 209, 208, 1, 0, 0, 0, 209, 210, 1, 0, 0, 0, 210, 227, 1, 0, 0, 0,
		211, 213, 5, 5, 0, 0, 212, 214, 5, 95, 0, 0, 213, 212, 1, 0, 0, 0, 213,
		214, 1, 0, 0, 0, 214, 216, 1, 0, 0, 0, 215, 217, 5, 4, 0, 0, 216, 215,
		1, 0, 0, 0, 216, 217, 1, 0, 0, 0, 217, 227, 1, 0, 0, 0, 218, 220, 5, 6,
		0, 0, 219, 221, 5, 95, 0, 0, 220, 219, 1, 0, 0, 0, 220, 221, 1, 0, 0, 0,
		221, 223, 1, 0, 0, 0, 222, 224, 5, 4, 0, 0, 223, 222, 1, 0, 0, 0, 223,
		224, 1, 0, 0, 0, 224, 227, 1, 0, 0, 0, 225, 227, 5, 4, 0, 0, 226, 181,
		1, 0, 0, 0, 226, 182, 1, 0, 0, 0, 226, 183, 1, 0, 0, 0, 226, 184, 1, 0,
		0, 0, 226, 185, 1, 0, 0, 0, 226, 186, 1, 0, 0, 0, 226, 187, 1, 0, 0, 0,
		226, 188, 1, 0, 0, 0, 226, 189, 1, 0, 0, 0, 226, 190, 1, 0, 0, 0, 226,
		191, 1, 0, 0, 0, 226, 192, 1, 0, 0, 0, 226, 193, 1, 0, 0, 0, 226, 194,
		1, 0, 0, 0, 226, 195, 1, 0, 0, 0, 226, 196, 1, 0, 0, 0, 226, 197, 1, 0,
		0, 0, 226, 198, 1, 0, 0, 0, 226, 199, 1, 0, 0, 0, 226, 200, 1, 0, 0, 0,
		226, 201, 1, 0, 0, 0, 226, 202, 1, 0, 0, 0, 226, 203, 1, 0, 0, 0, 226,
		204, 1, 0, 0, 0, 226, 211, 1, 0, 0, 0, 226, 218, 1, 0, 0, 0, 226, 225,
		1, 0, 0, 0, 227, 5, 1, 0, 0, 0, 228, 231, 3, 8, 4, 0, 229, 231, 3, 82,
		41, 0, 230, 228, 1, 0, 0, 0, 230, 229, 1, 0, 0, 0, 231, 7, 1, 0, 0, 0,
		232, 237, 3, 10, 5, 0, 233, 234, 7, 0, 0, 0, 234, 236, 3, 10, 5, 0, 235,
		233, 1, 0, 0, 0, 236, 239, 1, 0, 0, 0, 237, 235, 1, 0, 0, 0, 237, 238,
		1, 0, 0, 0, 238, 9, 1, 0, 0, 0, 239, 237, 1, 0, 0, 0, 240, 245, 3, 12,
		6, 0, 241, 242, 7, 1, 0, 0, 242, 244, 3, 12, 6, 0, 243, 241, 1, 0, 0, 0,
		244, 247, 1, 0, 0, 0, 245, 243, 1, 0, 0, 0, 245, 246, 1, 0, 0, 0, 246,
		11, 1, 0, 0, 0, 247, 245, 1, 0, 0, 0, 248, 253, 3, 14, 7, 0, 249, 250,
		7, 2, 0, 0, 250, 252, 3, 14, 7, 0, 251, 249, 1, 0, 0, 0, 252, 255, 1, 0,
		0, 0, 253, 251, 1, 0, 0, 0, 253, 254, 1, 0, 0, 0, 254, 13, 1, 0, 0, 0,
		255, 253, 1, 0, 0, 0, 256, 261, 3, 16, 8, 0, 257, 258, 7, 3, 0, 0, 258,
		260, 3, 16, 8, 0, 259, 257, 1, 0, 0, 0, 260, 263, 1, 0, 0, 0, 261, 259,
		1, 0, 0, 0, 261, 262, 1, 0, 0, 0, 262, 15, 1, 0, 0, 0, 263, 261, 1, 0,
		0, 0, 264, 268, 3, 22, 11, 0, 265, 267, 3, 18, 9, 0, 266, 265, 1, 0, 0,
		0, 267, 270, 1, 0, 0, 0, 268, 266, 1, 0, 0, 0, 268, 269, 1, 0, 0, 0, 269,
		17, 1, 0, 0, 0, 270, 268, 1, 0, 0, 0, 271, 272, 5, 20, 0, 0, 272, 273,
		3, 6, 3, 0, 273, 274, 5, 21, 0, 0, 274, 282, 1, 0, 0, 0, 275, 276, 5, 22,
		0, 0, 276, 277, 3, 6, 3, 0, 277, 278, 5, 23, 0, 0, 278, 279, 3, 6, 3, 0,
		279, 282, 1, 0, 0, 0, 280, 282, 3, 28, 14, 0, 281, 271, 1, 0, 0, 0, 281,
		275, 1, 0, 0, 0, 281, 280, 1, 0, 0, 0, 282, 19, 1, 0, 0, 0, 283, 284, 7,
		4, 0, 0, 284, 291, 5, 99, 0, 0, 285, 286, 5, 99, 0, 0, 286, 291, 7, 4,
		0, 0, 287, 288, 5, 99, 0, 0, 288, 289, 7, 5, 0, 0, 289, 291, 3, 6, 3, 0,
		290, 283, 1, 0, 0, 0, 290, 285, 1, 0, 0, 0, 290, 287, 1, 0, 0, 0, 291,
		21, 1, 0, 0, 0, 292, 305, 5, 95, 0, 0, 293, 305, 5, 96, 0, 0, 294, 305,
		5, 97, 0, 0, 295, 305, 5, 98, 0, 0, 296, 305, 5, 99, 0, 0, 297, 305, 3,
		24, 12, 0, 298, 305, 3, 26, 13, 0, 299, 305, 3, 106, 53, 0, 300, 305, 3,
		30, 15, 0, 301, 305, 3, 32, 16, 0, 302, 305, 3, 156, 78, 0, 303, 305, 3,
		20, 10, 0, 304, 292, 1, 0, 0, 0, 304, 293, 1, 0, 0, 0, 304, 294, 1, 0,
		0, 0, 304, 295, 1, 0, 0, 0, 304, 296, 1, 0, 0, 0, 304, 297, 1, 0, 0, 0,
		304, 298, 1, 0, 0, 0, 304, 299, 1, 0, 0, 0, 304, 300, 1, 0, 0, 0, 304,
		301, 1, 0, 0, 0, 304, 302, 1, 0, 0, 0, 304, 303, 1, 0, 0, 0, 305, 23, 1,
		0, 0, 0, 306, 307, 5, 31, 0, 0, 307, 308, 3, 6, 3, 0, 308, 309, 5, 32,
		0, 0, 309, 25, 1, 0, 0, 0, 310, 311, 3, 156, 78, 0, 311, 313, 5, 31, 0,
		0, 312, 314, 3, 44, 22, 0, 313, 312, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0,
		314, 315, 1, 0, 0, 0, 315, 316, 5, 32, 0, 0, 316, 326, 1, 0, 0, 0, 317,
		318, 5, 33, 0, 0, 318, 319, 3, 156, 78, 0, 319, 321, 5, 31, 0, 0, 320,
		322, 3, 44, 22, 0, 321, 320, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323,
		1, 0, 0, 0, 323, 324, 5, 32, 0, 0, 324, 326, 1, 0, 0, 0, 325, 310, 1, 0,
		0, 0, 325, 317, 1, 0, 0, 0, 326, 27, 1, 0, 0, 0, 327, 328, 5, 34, 0, 0,
		328, 329, 3, 156, 78, 0, 329, 331, 5, 31, 0, 0, 330, 332, 3, 44, 22, 0,
		331, 330, 1, 0, 0, 0, 331, 332, 1, 0, 0, 0, 332, 333, 1, 0, 0, 0, 333,
		334, 5, 32, 0, 0, 334, 338, 1, 0, 0, 0, 335, 336, 5, 34, 0, 0, 336, 338,
		3, 156, 78, 0, 337, 327, 1, 0, 0, 0, 337, 335, 1, 0, 0, 0, 338, 29, 1,
		0, 0, 0, 339, 340, 5, 20, 0, 0, 340, 345, 3, 6, 3, 0, 341, 342, 5, 35,
		0, 0, 342, 344, 3, 6, 3, 0, 343, 341, 1, 0, 0, 0, 344, 347, 1, 0, 0, 0,
		345, 343, 1, 0, 0, 0, 345, 346, 1, 0, 0, 0, 346, 348, 1, 0, 0, 0, 347,
		345, 1, 0, 0, 0, 348, 349, 5, 21, 0, 0, 349, 31, 1, 0, 0, 0, 350, 351,
		5, 20, 0, 0, 351, 352, 3, 6, 3, 0, 352, 353, 5, 23, 0, 0, 353, 361, 3,
		6, 3, 0, 354, 355, 5, 35, 0, 0, 355, 356, 3, 6, 3, 0, 356, 357, 5, 23,
		0, 0, 357, 358, 3, 6, 3, 0, 358, 360, 1, 0, 0, 0, 359, 354, 1, 0, 0, 0,
		360, 363, 1, 0, 0, 0, 361, 359, 1, 0, 0, 0, 361, 362, 1, 0, 0, 0, 362,
		364, 1, 0, 0, 0, 363, 361, 1, 0, 0, 0, 364, 365, 5, 21, 0, 0, 365, 33,
		1, 0, 0, 0, 366, 367, 5, 36, 0, 0, 367, 368, 7, 6, 0, 0, 368, 35, 1, 0,
		0, 0, 369, 370, 5, 40, 0, 0, 370, 372, 5, 99, 0, 0, 371, 373, 3, 34, 17,
		0, 372, 371, 1, 0, 0, 0, 372, 373, 1, 0, 0, 0, 373, 37, 1, 0, 0, 0, 374,
		375, 5, 41, 0, 0, 375, 378, 5, 99, 0, 0, 376, 377, 5, 42, 0, 0, 377, 379,
		5, 99, 0, 0, 378, 376, 1, 0, 0, 0, 378, 379, 1, 0, 0, 0, 379, 382, 1, 0,
		0, 0, 380, 381, 5, 43, 0, 0, 381, 383, 5, 98, 0, 0, 382, 380, 1, 0, 0,
		0, 382, 383, 1, 0, 0, 0, 383, 39, 1, 0, 0, 0, 384, 386, 5, 99, 0, 0, 385,
		387, 3, 58, 29, 0, 386, 385, 1, 0, 0, 0, 386, 387, 1, 0, 0, 0, 387, 390,
		1, 0, 0, 0, 388, 389, 5, 44, 0, 0, 389, 391, 3, 6, 3, 0, 390, 388, 1, 0,
		0, 0, 390, 391, 1, 0, 0, 0, 391, 41, 1, 0, 0, 0, 392, 397, 3, 40, 20, 0,
		393, 394, 5, 35, 0, 0, 394, 396, 3, 40, 20, 0, 395, 393, 1, 0, 0, 0, 396,
		399, 1, 0, 0, 0, 397, 395, 1, 0, 0, 0, 397, 398, 1, 0, 0, 0, 398, 403,
		1, 0, 0, 0, 399, 397, 1, 0, 0, 0, 400, 401, 5, 35, 0, 0, 401, 402, 5, 45,
		0, 0, 402, 404, 3, 40, 20, 0, 403, 400, 1, 0, 0, 0, 403, 404, 1, 0, 0,
		0, 404, 408, 1, 0, 0, 0, 405, 406, 5, 45, 0, 0, 406, 408, 3, 40, 20, 0,
		407, 392, 1, 0, 0, 0, 407, 405, 1, 0, 0, 0, 408, 43, 1, 0, 0, 0, 409, 414,
		3, 6, 3, 0, 410, 411, 5, 35, 0, 0, 411, 413, 3, 6, 3, 0, 412, 410, 1, 0,
		0, 0, 413, 416, 1, 0, 0, 0, 414, 412, 1, 0, 0, 0, 414, 415, 1, 0, 0, 0,
		415, 45, 1, 0, 0, 0, 416, 414, 1, 0, 0, 0, 417, 418, 5, 46, 0, 0, 418,
		431, 5, 99, 0, 0, 419, 428, 5, 31, 0, 0, 420, 425, 3, 52, 26, 0, 421, 422,
		5, 35, 0, 0, 422, 424, 3, 52, 26, 0, 423, 421, 1, 0, 0, 0, 424, 427, 1,
		0, 0, 0, 425, 423, 1, 0, 0, 0, 425, 426, 1, 0, 0, 0, 426, 429, 1, 0, 0,
		0, 427, 425, 1, 0, 0, 0, 428, 420, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429,
		430, 1, 0, 0, 0, 430, 432, 5, 32, 0, 0, 431, 419, 1, 0, 0, 0, 431, 432,
		1, 0, 0, 0, 432, 47, 1, 0, 0, 0, 433, 435, 3, 46, 23, 0, 434, 433, 1, 0,
		0, 0, 435, 438, 1, 0, 0, 0, 436, 434, 1, 0, 0, 0, 436, 437, 1, 0, 0, 0,
		437, 49, 1, 0, 0, 0, 438, 436, 1, 0, 0, 0, 439, 440, 5, 99, 0, 0, 440,
		441, 5, 44, 0, 0, 441, 51, 1, 0, 0, 0, 442, 444, 3, 50, 25, 0, 443, 442,
		1, 0, 0, 0, 443, 444, 1, 0, 0, 0, 444, 445, 1, 0, 0, 0, 445, 446, 7, 7,
		0, 0, 446, 53, 1, 0, 0, 0, 447, 448, 5, 47, 0, 0, 448, 449, 5, 99, 0, 0,
		449, 450, 5, 31, 0, 0, 450, 451, 3, 42, 21, 0, 451, 452, 5, 32, 0, 0, 452,
		55, 1, 0, 0, 0, 453, 454, 7, 8, 0, 0, 454, 57, 1, 0, 0, 0, 455, 456, 5,
		23, 0, 0, 456, 457, 3, 140, 70, 0, 457, 59, 1, 0, 0, 0, 458, 459, 5, 31,
		0, 0, 459, 464, 5, 99, 0, 0, 460, 461, 5, 35, 0, 0, 461, 463, 5, 99, 0,
		0, 462, 460, 1, 0, 0, 0, 463, 466, 1, 0, 0, 0, 464, 462, 1, 0, 0, 0, 464,
		465, 1, 0, 0, 0, 465, 467, 1, 0, 0, 0, 466, 464, 1, 0, 0, 0, 467, 468,
		5, 32, 0, 0, 468, 61, 1, 0, 0, 0, 469, 472, 5, 99, 0, 0, 470, 472, 3, 60,
		30, 0, 471, 469, 1, 0, 0, 0, 471, 470, 1, 0, 0, 0, 472, 63, 1, 0, 0, 0,
		473, 475, 3, 56, 28, 0, 474, 473, 1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475,
		476, 1, 0, 0, 0, 476, 479, 5, 51, 0, 0, 477, 479, 5, 52, 0, 0, 478, 474,
		1, 0, 0, 0, 478, 477, 1, 0, 0, 0, 479, 65, 1, 0, 0, 0, 480, 482, 3, 64,
		32, 0, 481, 480, 1, 0, 0, 0, 481, 482, 1, 0, 0, 0, 482, 483, 1, 0, 0, 0,
		483, 485, 3, 62, 31, 0, 484, 486, 3, 58, 29, 0, 485, 484, 1, 0, 0, 0, 485,
		486, 1, 0, 0, 0, 486, 489, 1, 0, 0, 0, 487, 488, 5, 44, 0, 0, 488, 490,
		3, 6, 3, 0, 489, 487, 1, 0, 0, 0, 489, 490, 1, 0, 0, 0, 490, 492, 1, 0,
		0, 0, 491, 493, 3, 74, 37, 0, 492, 491, 1, 0, 0, 0, 492, 493, 1, 0, 0,
		0, 493, 495, 1, 0, 0, 0, 494, 496, 5, 4, 0, 0, 495, 494, 1, 0, 0, 0, 495,
		496, 1, 0, 0, 0, 496, 67, 1, 0, 0, 0, 497, 499, 3, 64, 32, 0, 498, 497,
		1, 0, 0, 0, 498, 499, 1, 0, 0, 0, 499, 500, 1, 0, 0, 0, 500, 505, 3, 62,
		31, 0, 501, 502, 5, 35, 0, 0, 502, 504, 3, 62, 31, 0, 503, 501, 1, 0, 0,
		0, 504, 507, 1, 0, 0, 0, 505, 503, 1, 0, 0, 0, 505, 506, 1, 0, 0, 0, 506,
		509, 1, 0, 0, 0, 507, 505, 1, 0, 0, 0, 508, 510, 3, 58, 29, 0, 509, 508,
		1, 0, 0, 0, 509, 510, 1, 0, 0, 0, 510, 520, 1, 0, 0, 0, 511, 512, 5, 44,
		0, 0, 512, 517, 3, 6, 3, 0, 513, 514, 5, 35, 0, 0, 514, 516, 3, 6, 3, 0,
		515, 513, 1, 0, 0, 0, 516, 519, 1, 0, 0, 0, 517, 515, 1, 0, 0, 0, 517,
		518, 1, 0, 0, 0, 518, 521, 1, 0, 0, 0, 519, 517, 1, 0, 0, 0, 520, 511,
		1, 0, 0, 0, 520, 521, 1, 0, 0, 0, 521, 523, 1, 0, 0, 0, 522, 524, 3, 74,
		37, 0, 523, 522, 1, 0, 0, 0, 523, 524, 1, 0, 0, 0, 524, 526, 1, 0, 0, 0,
		525, 527, 5, 4, 0, 0, 526, 525, 1, 0, 0, 0, 526, 527, 1, 0, 0, 0, 527,
		69, 1, 0, 0, 0, 528, 530, 3, 48, 24, 0, 529, 528, 1, 0, 0, 0, 529, 530,
		1, 0, 0, 0, 530, 532, 1, 0, 0, 0, 531, 533, 3, 56, 28, 0, 532, 531, 1,
		0, 0, 0, 532, 533, 1, 0, 0, 0, 533, 535, 1, 0, 0, 0, 534, 536, 5, 53, 0,
		0, 535, 534, 1, 0, 0, 0, 535, 536, 1, 0, 0, 0, 536, 539, 1, 0, 0, 0, 537,
		540, 3, 66, 33, 0, 538, 540, 3, 68, 34, 0, 539, 537, 1, 0, 0, 0, 539, 538,
		1, 0, 0, 0, 540, 71, 1, 0, 0, 0, 541, 542, 7, 9, 0, 0, 542, 73, 1, 0, 0,
		0, 543, 545, 5, 56, 0, 0, 544, 546, 3, 72, 36, 0, 545, 544, 1, 0, 0, 0,
		545, 546, 1, 0, 0, 0, 546, 548, 1, 0, 0, 0, 547, 549, 3, 76, 38, 0, 548,
		547, 1, 0, 0, 0, 548, 549, 1, 0, 0, 0, 549, 551, 1, 0, 0, 0, 550, 552,
		3, 34, 17, 0, 551, 550, 1, 0, 0, 0, 551, 552, 1, 0, 0, 0, 552, 75, 1, 0,
		0, 0, 553, 555, 5, 57, 0, 0, 554, 556, 5, 31, 0, 0, 555, 554, 1, 0, 0,
		0, 555, 556, 1, 0, 0, 0, 556, 568, 1, 0, 0, 0, 557, 569, 5, 98, 0, 0, 558,
		559, 5, 20, 0, 0, 559, 564, 5, 98, 0, 0, 560, 561, 5, 35, 0, 0, 561, 563,
		5, 98, 0, 0, 562, 560, 1, 0, 0, 0, 563, 566, 1, 0, 0, 0, 564, 562, 1, 0,
		0, 0, 564, 565, 1, 0, 0, 0, 565, 567, 1, 0, 0, 0, 566, 564, 1, 0, 0, 0,
		567, 569, 5, 21, 0, 0, 568, 557, 1, 0, 0, 0, 568, 558, 1, 0, 0, 0, 569,
		571, 1, 0, 0, 0, 570, 572, 5, 32, 0, 0, 571, 570, 1, 0, 0, 0, 571, 572,
		1, 0, 0, 0, 572, 77, 1, 0, 0, 0, 573, 575, 3, 48, 24, 0, 574, 573, 1, 0,
		0, 0, 574, 575, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 577, 5, 58, 0, 0,
		577, 579, 5, 99, 0, 0, 578, 580, 3, 152, 76, 0, 579, 578, 1, 0, 0, 0, 579,
		580, 1, 0, 0, 0, 580, 581, 1, 0, 0, 0, 581, 583, 5, 31, 0, 0, 582, 584,
		3, 42, 21, 0, 583, 582, 1, 0, 0, 0, 583, 584, 1, 0, 0, 0, 584, 585, 1,
		0, 0, 0, 585, 587, 5, 32, 0, 0, 586, 588, 3, 58, 29, 0, 587, 586, 1, 0,
		0, 0, 587, 588, 1, 0, 0, 0, 588, 590, 1, 0, 0, 0, 589, 591, 3, 74, 37,
		0, 590, 589, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0, 592,
		593, 3, 2, 1, 0, 593, 79, 1, 0, 0, 0, 594, 596, 3, 48, 24, 0, 595, 594,
		1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 598, 1, 0, 0, 0, 597, 599, 3, 56,
		28, 0, 598, 597, 1, 0, 0, 0, 598, 599, 1, 0, 0, 0, 599, 601, 1, 0, 0, 0,
		600, 602, 5, 53, 0, 0, 601, 600, 1, 0, 0, 0, 601, 602, 1, 0, 0, 0, 602,
		603, 1, 0, 0, 0, 603, 604, 5, 58, 0, 0, 604, 606, 5, 99, 0, 0, 605, 607,
		3, 152, 76, 0, 606, 605, 1, 0, 0, 0, 606, 607, 1, 0, 0, 0, 607, 608, 1,
		0, 0, 0, 608, 610, 5, 31, 0, 0, 609, 611, 3, 42, 21, 0, 610, 609, 1, 0,
		0, 0, 610, 611, 1, 0, 0, 0, 611, 612, 1, 0, 0, 0, 612, 614, 5, 32, 0, 0,
		613, 615, 3, 58, 29, 0, 614, 613, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615,
		616, 1, 0, 0, 0, 616, 617, 3, 2, 1, 0, 617, 81, 1, 0, 0, 0, 618, 620, 5,
		31, 0, 0, 619, 621, 3, 42, 21, 0, 620, 619, 1, 0, 0, 0, 620, 621, 1, 0,
		0, 0, 621, 622, 1, 0, 0, 0, 622, 624, 5, 32, 0, 0, 623, 625, 3, 58, 29,
		0, 624, 623, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 626, 1, 0, 0, 0, 626,
		629, 5, 59, 0, 0, 627, 630, 3, 2, 1, 0, 628, 630, 3, 6, 3, 0, 629, 627,
		1, 0, 0, 0, 629, 628, 1, 0, 0, 0, 630, 83, 1, 0, 0, 0, 631, 633, 5, 31,
		0, 0, 632, 634, 3, 42, 21, 0, 633, 632, 1, 0, 0, 0, 633, 634, 1, 0, 0,
		0, 634, 635, 1, 0, 0, 0, 635, 636, 5, 32, 0, 0, 636, 85, 1, 0, 0, 0, 637,
		639, 3, 48, 24, 0, 638, 637, 1, 0, 0, 0, 638, 639, 1, 0, 0, 0, 639, 641,
		1, 0, 0, 0, 640, 642, 3, 56, 28, 0, 641, 640, 1, 0, 0, 0, 641, 642, 1,
		0, 0, 0, 642, 643, 1, 0, 0, 0, 643, 644, 5, 60, 0, 0, 644, 645, 3, 84,
		42, 0, 645, 646, 3, 2, 1, 0, 646, 87, 1, 0, 0, 0, 647, 649, 3, 48, 24,
		0, 648, 650, 3, 56, 28, 0, 649, 648, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0,
		650, 651, 1, 0, 0, 0, 651, 652, 5, 61, 0, 0, 652, 653, 5, 99, 0, 0, 653,
		654, 3, 84, 42, 0, 654, 655, 5, 1, 0, 0, 655, 660, 3, 90, 45, 0, 656, 657,
		5, 35, 0, 0, 657, 659, 3, 90, 45, 0, 658, 656, 1, 0, 0, 0, 659, 662, 1,
		0, 0, 0, 660, 658, 1, 0, 0, 0, 660, 661, 1, 0, 0, 0, 661, 666, 1, 0, 0,
		0, 662, 660, 1, 0, 0, 0, 663, 665, 3, 80, 40, 0, 664, 663, 1, 0, 0, 0,
		665, 668, 1, 0, 0, 0, 666, 664, 1, 0, 0, 0, 666, 667, 1, 0, 0, 0, 667,
		669, 1, 0, 0, 0, 668, 666, 1, 0, 0, 0, 669, 670, 5, 2, 0, 0, 670, 89, 1,
		0, 0, 0, 671, 672, 3, 48, 24, 0, 672, 678, 5, 99, 0, 0, 673, 675, 5, 31,
		0, 0, 674, 676, 3, 44, 22, 0, 675, 674, 1, 0, 0, 0, 675, 676, 1, 0, 0,
		0, 676, 677, 1, 0, 0, 0, 677, 679, 5, 32, 0, 0, 678, 673, 1, 0, 0, 0, 678,
		679, 1, 0, 0, 0, 679, 91, 1, 0, 0, 0, 680, 682, 3, 56, 28, 0, 681, 680,
		1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 683, 1, 0, 0, 0, 683, 684, 5, 62,
		0, 0, 684, 686, 5, 99, 0, 0, 685, 687, 3, 152, 76, 0, 686, 685, 1, 0, 0,
		0, 686, 687, 1, 0, 0, 0, 687, 689, 1, 0, 0, 0, 688, 690, 3, 160, 80, 0,
		689, 688, 1, 0, 0, 0, 689, 690, 1, 0, 0, 0, 690, 691, 1, 0, 0, 0, 691,
		695, 5, 1, 0, 0, 692, 694, 3, 94, 47, 0, 693, 692, 1, 0, 0, 0, 694, 697,
		1, 0, 0, 0, 695, 693, 1, 0, 0, 0, 695, 696, 1, 0, 0, 0, 696, 698, 1, 0,
		0, 0, 697, 695, 1, 0, 0, 0, 698, 699, 5, 2, 0, 0, 699, 93, 1, 0, 0, 0,
		700, 703, 3, 96, 48, 0, 701, 703, 3, 98, 49, 0, 702, 700, 1, 0, 0, 0, 702,
		701, 1, 0, 0, 0, 703, 95, 1, 0, 0, 0, 704, 706, 3, 64, 32, 0, 705, 704,
		1, 0, 0, 0, 705, 706, 1, 0, 0, 0, 706, 707, 1, 0, 0, 0, 707, 708, 5, 99,
		0, 0, 708, 709, 3, 58, 29, 0, 709, 97, 1, 0, 0, 0, 710, 712, 5, 99, 0,
		0, 711, 713, 3, 152, 76, 0, 712, 711, 1, 0, 0, 0, 712, 713, 1, 0, 0, 0,
		713, 714, 1, 0, 0, 0, 714, 716, 5, 31, 0, 0, 715, 717, 3, 42, 21, 0, 716,
		715, 1, 0, 0, 0, 716, 717, 1, 0, 0, 0, 717, 718, 1, 0, 0, 0, 718, 719,
		5, 32, 0, 0, 719, 720, 3, 58, 29, 0, 720, 99, 1, 0, 0, 0, 721, 723, 3,
		48, 24, 0, 722, 724, 3, 56, 28, 0, 723, 722, 1, 0, 0, 0, 723, 724, 1, 0,
		0, 0, 724, 725, 1, 0, 0, 0, 725, 726, 5, 63, 0, 0, 726, 728, 5, 99, 0,
		0, 727, 729, 3, 152, 76, 0, 728, 727, 1, 0, 0, 0, 728, 729, 1, 0, 0, 0,
		729, 731, 1, 0, 0, 0, 730, 732, 3, 84, 42, 0, 731, 730, 1, 0, 0, 0, 731,
		732, 1, 0, 0, 0, 732, 734, 1, 0, 0, 0, 733, 735, 3, 158, 79, 0, 734, 733,
		1, 0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 737, 1, 0, 0, 0, 736, 738, 3, 162,
		81, 0, 737, 736, 1, 0, 0, 0, 737, 738, 1, 0, 0, 0, 738, 740, 1, 0, 0, 0,
		739, 741, 3, 34, 17, 0, 740, 739, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741,
		742, 1, 0, 0, 0, 742, 746, 5, 1, 0, 0, 743, 745, 3, 102, 51, 0, 744, 743,
		1, 0, 0, 0, 745, 748, 1, 0, 0, 0, 746, 744, 1, 0, 0, 0, 746, 747, 1, 0,
		0, 0, 747, 749, 1, 0, 0, 0, 748, 746, 1, 0, 0, 0, 749, 750, 5, 2, 0, 0,
		750, 101, 1, 0, 0, 0, 751, 758, 3, 70, 35, 0, 752, 758, 3, 80, 40, 0, 753,
		758, 3, 86, 43, 0, 754, 758, 3, 100, 50, 0, 755, 758, 3, 92, 46, 0, 756,
		758, 3, 88, 44, 0, 757, 751, 1, 0, 0, 0, 757, 752, 1, 0, 0, 0, 757, 753,
		1, 0, 0, 0, 757, 754, 1, 0, 0, 0, 757, 755, 1, 0, 0, 0, 757, 756, 1, 0,
		0, 0, 758, 103, 1, 0, 0, 0, 759, 761, 5, 64, 0, 0, 760, 762, 5, 31, 0,
		0, 761, 760, 1, 0, 0, 0, 761, 762, 1, 0, 0, 0, 762, 763, 1, 0, 0, 0, 763,
		765, 3, 6, 3, 0, 764, 766, 5, 32, 0, 0, 765, 764, 1, 0, 0, 0, 765, 766,
		1, 0, 0, 0, 766, 767, 1, 0, 0, 0, 767, 780, 3, 2, 1, 0, 768, 770, 5, 65,
		0, 0, 769, 771, 5, 31, 0, 0, 770, 769, 1, 0, 0, 0, 770, 771, 1, 0, 0, 0,
		771, 772, 1, 0, 0, 0, 772, 774, 3, 6, 3, 0, 773, 775, 5, 32, 0, 0, 774,
		773, 1, 0, 0, 0, 774, 775, 1, 0, 0, 0, 775, 776, 1, 0, 0, 0, 776, 777,
		3, 2, 1, 0, 777, 779, 1, 0, 0, 0, 778, 768, 1, 0, 0, 0, 779, 782, 1, 0,
		0, 0, 780, 778, 1, 0, 0, 0, 780, 781, 1, 0, 0, 0, 781, 785, 1, 0, 0, 0,
		782, 780, 1, 0, 0, 0, 783, 784, 5, 66, 0, 0, 784, 786, 3, 2, 1, 0, 785,
		783, 1, 0, 0, 0, 785, 786, 1, 0, 0, 0, 786, 105, 1, 0, 0, 0, 787, 789,
		5, 67, 0, 0, 788, 790, 5, 31, 0, 0, 789, 788, 1, 0, 0, 0, 789, 790, 1,
		0, 0, 0, 790, 791, 1, 0, 0, 0, 791, 793, 3, 6, 3, 0, 792, 794, 5, 32, 0,
		0, 793, 792, 1, 0, 0, 0, 793, 794, 1, 0, 0, 0, 794, 795, 1, 0, 0, 0, 795,
		799, 5, 1, 0, 0, 796, 798, 3, 108, 54, 0, 797, 796, 1, 0, 0, 0, 798, 801,
		1, 0, 0, 0, 799, 797, 1, 0, 0, 0, 799, 800, 1, 0, 0, 0, 800, 802, 1, 0,
		0, 0, 801, 799, 1, 0, 0, 0, 802, 803, 5, 66, 0, 0, 803, 804, 5, 68, 0,
		0, 804, 805, 3, 110, 55, 0, 805, 806, 1, 0, 0, 0, 806, 807, 5, 2, 0, 0,
		807, 107, 1, 0, 0, 0, 808, 809, 3, 6, 3, 0, 809, 810, 5, 68, 0, 0, 810,
		811, 3, 110, 55, 0, 811, 109, 1, 0, 0, 0, 812, 816, 5, 1, 0, 0, 813, 815,
		3, 4, 2, 0, 814, 813, 1, 0, 0, 0, 815, 818, 1, 0, 0, 0, 816, 814, 1, 0,
		0, 0, 816, 817, 1, 0, 0, 0, 817, 819, 1, 0, 0, 0, 818, 816, 1, 0, 0, 0,
		819, 822, 5, 2, 0, 0, 820, 822, 3, 6, 3, 0, 821, 812, 1, 0, 0, 0, 821,
		820, 1, 0, 0, 0, 822, 111, 1, 0, 0, 0, 823, 825, 5, 69, 0, 0, 824, 826,
		5, 31, 0, 0, 825, 824, 1, 0, 0, 0, 825, 826, 1, 0, 0, 0, 826, 828, 1, 0,
		0, 0, 827, 829, 3, 66, 33, 0, 828, 827, 1, 0, 0, 0, 828, 829, 1, 0, 0,
		0, 829, 830, 1, 0, 0, 0, 830, 832, 5, 4, 0, 0, 831, 833, 3, 6, 3, 0, 832,
		831, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833, 834, 1, 0, 0, 0, 834, 836,
		5, 4, 0, 0, 835, 837, 3, 114, 57, 0, 836, 835, 1, 0, 0, 0, 836, 837, 1,
		0, 0, 0, 837, 839, 1, 0, 0, 0, 838, 840, 5, 32, 0, 0, 839, 838, 1, 0, 0,
		0, 839, 840, 1, 0, 0, 0, 840, 841, 1, 0, 0, 0, 841, 842, 3, 2, 1, 0, 842,
		113, 1, 0, 0, 0, 843, 844, 5, 99, 0, 0, 844, 851, 7, 4, 0, 0, 845, 846,
		7, 4, 0, 0, 846, 851, 5, 99, 0, 0, 847, 848, 5, 99, 0, 0, 848, 849, 7,
		10, 0, 0, 849, 851, 3, 6, 3, 0, 850, 843, 1, 0, 0, 0, 850, 845, 1, 0, 0,
		0, 850, 847, 1, 0, 0, 0, 851, 115, 1, 0, 0, 0, 852, 854, 5, 69, 0, 0, 853,
		855, 5, 31, 0, 0, 854, 853, 1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 856,
		1, 0, 0, 0, 856, 861, 3, 62, 31, 0, 857, 858, 5, 35, 0, 0, 858, 860, 3,
		62, 31, 0, 859, 857, 1, 0, 0, 0, 860, 863, 1, 0, 0, 0, 861, 859, 1, 0,
		0, 0, 861, 862, 1, 0, 0, 0, 862, 864, 1, 0, 0, 0, 863, 861, 1, 0, 0, 0,
		864, 865, 5, 70, 0, 0, 865, 867, 3, 6, 3, 0, 866, 868, 5, 32, 0, 0, 867,
		866, 1, 0, 0, 0, 867, 868, 1, 0, 0, 0, 868, 869, 1, 0, 0, 0, 869, 870,
		3, 2, 1, 0, 870, 117, 1, 0, 0, 0, 871, 873, 5, 71, 0, 0, 872, 874, 5, 31,
		0, 0, 873, 872, 1, 0, 0, 0, 873, 874, 1, 0, 0, 0, 874, 875, 1, 0, 0, 0,
		875, 877, 3, 6, 3, 0, 876, 878, 5, 32, 0, 0, 877, 876, 1, 0, 0, 0, 877,
		878, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 880, 3, 2, 1, 0, 880, 119,
		1, 0, 0, 0, 881, 882, 5, 72, 0, 0, 882, 883, 3, 2, 1, 0, 883, 885, 5, 71,
		0, 0, 884, 886, 5, 31, 0, 0, 885, 884, 1, 0, 0, 0, 885, 886, 1, 0, 0, 0,
		886, 887, 1, 0, 0, 0, 887, 889, 3, 6, 3, 0, 888, 890, 5, 32, 0, 0, 889,
		888, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 121, 1, 0, 0, 0, 891, 906,
		5, 73, 0, 0, 892, 904, 5, 74, 0, 0, 893, 905, 5, 98, 0, 0, 894, 895, 5,
		20, 0, 0, 895, 900, 5, 98, 0, 0, 896, 897, 5, 35, 0, 0, 897, 899, 5, 98,
		0, 0, 898, 896, 1, 0, 0, 0, 899, 902, 1, 0, 0, 0, 900, 898, 1, 0, 0, 0,
		900, 901, 1, 0, 0, 0, 901, 903, 1, 0, 0, 0, 902, 900, 1, 0, 0, 0, 903,
		905, 5, 21, 0, 0, 904, 893, 1, 0, 0, 0, 904, 894, 1, 0, 0, 0, 905, 907,
		1, 0, 0, 0, 906, 892, 1, 0, 0, 0, 906, 907, 1, 0, 0, 0, 907, 123, 1, 0,
		0, 0, 908, 911, 5, 75, 0, 0, 909, 912, 5, 76, 0, 0, 910, 912, 3, 30, 15,
		0, 911, 909, 1, 0, 0, 0, 911, 910, 1, 0, 0, 0, 912, 125, 1, 0, 0, 0, 913,
		914, 5, 77, 0, 0, 914, 915, 5, 1, 0, 0, 915, 916, 3, 128, 64, 0, 916, 917,
		5, 2, 0, 0, 917, 127, 1, 0, 0, 0, 918, 920, 3, 130, 65, 0, 919, 918, 1,
		0, 0, 0, 920, 923, 1, 0, 0, 0, 921, 919, 1, 0, 0, 0, 921, 922, 1, 0, 0,
		0, 922, 129, 1, 0, 0, 0, 923, 921, 1, 0, 0, 0, 924, 926, 5, 98, 0, 0, 925,
		927, 3, 132, 66, 0, 926, 925, 1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 928,
		1, 0, 0, 0, 928, 929, 5, 78, 0, 0, 929, 930, 3, 30, 15, 0, 930, 131, 1,
		0, 0, 0, 931, 932, 5, 79, 0, 0, 932, 937, 5, 98, 0, 0, 933, 934, 5, 35,
		0, 0, 934, 936, 5, 98, 0, 0, 935, 933, 1, 0, 0, 0, 936, 939, 1, 0, 0, 0,
		937, 935, 1, 0, 0, 0, 937, 938, 1, 0, 0, 0, 938, 942, 1, 0, 0, 0, 939,
		937, 1, 0, 0, 0, 940, 941, 5, 80, 0, 0, 941, 943, 3, 30, 15, 0, 942, 940,
		1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 133, 1, 0, 0, 0, 944, 946, 5, 81,
		0, 0, 945, 947, 5, 99, 0, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0,
		947, 948, 1, 0, 0, 0, 948, 949, 5, 1, 0, 0, 949, 950, 3, 136, 68, 0, 950,
		951, 5, 2, 0, 0, 951, 135, 1, 0, 0, 0, 952, 954, 3, 138, 69, 0, 953, 952,
		1, 0, 0, 0, 954, 957, 1, 0, 0, 0, 955, 953, 1, 0, 0, 0, 955, 956, 1, 0,
		0, 0, 956, 137, 1, 0, 0, 0, 957, 955, 1, 0, 0, 0, 958, 959, 5, 99, 0, 0,
		959, 960, 5, 23, 0, 0, 960, 961, 3, 6, 3, 0, 961, 139, 1, 0, 0, 0, 962,
		968, 3, 142, 71, 0, 963, 968, 3, 144, 72, 0, 964, 968, 3, 146, 73, 0, 965,
		968, 3, 148, 74, 0, 966, 968, 5, 99, 0, 0, 967, 962, 1, 0, 0, 0, 967, 963,
		1, 0, 0, 0, 967, 964, 1, 0, 0, 0, 967, 965, 1, 0, 0, 0, 967, 966, 1, 0,
		0, 0, 968, 141, 1, 0, 0, 0, 969, 970, 7, 11, 0, 0, 970, 143, 1, 0, 0, 0,
		971, 972, 5, 87, 0, 0, 972, 973, 3, 140, 70, 0, 973, 145, 1, 0, 0, 0, 974,
		975, 5, 20, 0, 0, 975, 976, 3, 140, 70, 0, 976, 977, 5, 21, 0, 0, 977,
		978, 3, 140, 70, 0, 978, 147, 1, 0, 0, 0, 979, 980, 5, 31, 0, 0, 980, 985,
		3, 140, 70, 0, 981, 982, 5, 35, 0, 0, 982, 984, 3, 140, 70, 0, 983, 981,
		1, 0, 0, 0, 984, 987, 1, 0, 0, 0, 985, 983, 1, 0, 0, 0, 985, 986, 1, 0,
		0, 0, 986, 988, 1, 0, 0, 0, 987, 985, 1, 0, 0, 0, 988, 989, 5, 32, 0, 0,
		989, 149, 1, 0, 0, 0, 990, 992, 5, 99, 0, 0, 991, 993, 3, 158, 79, 0, 992,
		991, 1, 0, 0, 0, 992, 993, 1, 0, 0, 0, 993, 995, 1, 0, 0, 0, 994, 996,
		3, 162, 81, 0, 995, 994, 1, 0, 0, 0, 995, 996, 1, 0, 0, 0, 996, 151, 1,
		0, 0, 0, 997, 998, 5, 9, 0, 0, 998, 1003, 3, 150, 75, 0, 999, 1000, 5,
		35, 0, 0, 1000, 1002, 3, 150, 75, 0, 1001, 999, 1, 0, 0, 0, 1002, 1005,
		1, 0, 0, 0, 1003, 1001, 1, 0, 0, 0, 1003, 1004, 1, 0, 0, 0, 1004, 1006,
		1, 0, 0, 0, 1005, 1003, 1, 0, 0, 0, 1006, 1007, 5, 11, 0, 0, 1007, 153,
		1, 0, 0, 0, 1008, 1009, 5, 9, 0, 0, 1009, 1010, 3, 140, 70, 0, 1010, 1011,
		5, 11, 0, 0, 1011, 155, 1, 0, 0, 0, 1012, 1014, 5, 88, 0, 0, 1013, 1012,
		1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 1015, 1, 0, 0, 0, 1015, 1017,
		5, 99, 0, 0, 1016, 1018, 3, 154, 77, 0, 1017, 1016, 1, 0, 0, 0, 1017, 1018,
		1, 0, 0, 0, 1018, 1023, 1, 0, 0, 0, 1019, 1020, 5, 34, 0, 0, 1020, 1022,
		3, 156, 78, 0, 1021, 1019, 1, 0, 0, 0, 1022, 1025, 1, 0, 0, 0, 1023, 1021,
		1, 0, 0, 0, 1023, 1024, 1, 0, 0, 0, 1024, 157, 1, 0, 0, 0, 1025, 1023,
		1, 0, 0, 0, 1026, 1027, 5, 89, 0, 0, 1027, 1028, 3, 156, 78, 0, 1028, 159,
		1, 0, 0, 0, 1029, 1030, 5, 89, 0, 0, 1030, 1035, 3, 156, 78, 0, 1031, 1032,
		5, 35, 0, 0, 1032, 1034, 3, 156, 78, 0, 1033, 1031, 1, 0, 0, 0, 1034, 1037,
		1, 0, 0, 0, 1035, 1033, 1, 0, 0, 0, 1035, 1036, 1, 0, 0, 0, 1036, 161,
		1, 0, 0, 0, 1037, 1035, 1, 0, 0, 0, 1038, 1039, 5, 90, 0, 0, 1039, 1044,
		3, 156, 78, 0, 1040, 1041, 5, 35, 0, 0, 1041, 1043, 3, 156, 78, 0, 1042,
		1040, 1, 0, 0, 0, 1043, 1046, 1, 0, 0, 0, 1044, 1042, 1, 0, 0, 0, 1044,
		1045, 1, 0, 0, 0, 1045, 163, 1, 0, 0, 0, 1046, 1044, 1, 0, 0, 0, 148, 167,
		176, 206, 209, 213, 216, 220, 223, 226, 230, 237, 245, 253, 261, 268, 281,
		290, 304, 313, 321, 325, 331, 337, 345, 361, 372, 378, 382, 386, 390, 397,
		403, 407, 414, 425, 428, 431, 436, 443, 464, 471, 474, 478, 481, 485, 489,
		492, 495, 498, 505, 509, 517, 520, 523, 526, 529, 532, 535, 539, 545, 548,
		551, 555, 564, 568, 571, 574, 579, 583, 587, 590, 595, 598, 601, 606, 610,
		614, 620, 624, 629, 633, 638, 641, 649, 660, 666, 675, 678, 681, 686, 689,
		695, 702, 705, 712, 716, 723, 728, 731, 734, 737, 740, 746, 757, 761, 765,
		770, 774, 780, 785, 789, 793, 799, 816, 821, 825, 828, 832, 836, 839, 850,
		854, 861, 867, 873, 877, 885, 889, 900, 904, 906, 911, 921, 926, 937, 942,
		946, 955, 967, 985, 992, 995, 1003, 1013, 1017, 1023, 1035, 1044,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// ggwParserInit initializes any static state used to implement ggwParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewggwParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func GgwParserInit() {
	staticData := &GgwParserStaticData
	staticData.once.Do(ggwParserInit)
}

// NewggwParser produces a new parser instance for the optional input antlr.TokenStream.
func NewggwParser(input antlr.TokenStream) *ggwParser {
	GgwParserInit()
	this := new(ggwParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &GgwParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "ggw.g4"

	return this
}

// ggwParser tokens.
const (
	ggwParserEOF                 = antlr.TokenEOF
	ggwParserT__0                = 1
	ggwParserT__1                = 2
	ggwParserT__2                = 3
	ggwParserT__3                = 4
	ggwParserT__4                = 5
	ggwParserT__5                = 6
	ggwParserT__6                = 7
	ggwParserT__7                = 8
	ggwParserT__8                = 9
	ggwParserT__9                = 10
	ggwParserT__10               = 11
	ggwParserT__11               = 12
	ggwParserT__12               = 13
	ggwParserT__13               = 14
	ggwParserT__14               = 15
	ggwParserT__15               = 16
	ggwParserT__16               = 17
	ggwParserT__17               = 18
	ggwParserT__18               = 19
	ggwParserT__19               = 20
	ggwParserT__20               = 21
	ggwParserT__21               = 22
	ggwParserT__22               = 23
	ggwParserT__23               = 24
	ggwParserT__24               = 25
	ggwParserT__25               = 26
	ggwParserT__26               = 27
	ggwParserT__27               = 28
	ggwParserT__28               = 29
	ggwParserT__29               = 30
	ggwParserT__30               = 31
	ggwParserT__31               = 32
	ggwParserT__32               = 33
	ggwParserT__33               = 34
	ggwParserT__34               = 35
	ggwParserT__35               = 36
	ggwParserT__36               = 37
	ggwParserT__37               = 38
	ggwParserT__38               = 39
	ggwParserT__39               = 40
	ggwParserT__40               = 41
	ggwParserT__41               = 42
	ggwParserT__42               = 43
	ggwParserT__43               = 44
	ggwParserT__44               = 45
	ggwParserT__45               = 46
	ggwParserT__46               = 47
	ggwParserT__47               = 48
	ggwParserT__48               = 49
	ggwParserT__49               = 50
	ggwParserT__50               = 51
	ggwParserT__51               = 52
	ggwParserT__52               = 53
	ggwParserT__53               = 54
	ggwParserT__54               = 55
	ggwParserT__55               = 56
	ggwParserT__56               = 57
	ggwParserT__57               = 58
	ggwParserT__58               = 59
	ggwParserT__59               = 60
	ggwParserT__60               = 61
	ggwParserT__61               = 62
	ggwParserT__62               = 63
	ggwParserT__63               = 64
	ggwParserT__64               = 65
	ggwParserT__65               = 66
	ggwParserT__66               = 67
	ggwParserT__67               = 68
	ggwParserT__68               = 69
	ggwParserT__69               = 70
	ggwParserT__70               = 71
	ggwParserT__71               = 72
	ggwParserT__72               = 73
	ggwParserT__73               = 74
	ggwParserT__74               = 75
	ggwParserT__75               = 76
	ggwParserT__76               = 77
	ggwParserT__77               = 78
	ggwParserT__78               = 79
	ggwParserT__79               = 80
	ggwParserT__80               = 81
	ggwParserT__81               = 82
	ggwParserT__82               = 83
	ggwParserT__83               = 84
	ggwParserT__84               = 85
	ggwParserT__85               = 86
	ggwParserT__86               = 87
	ggwParserT__87               = 88
	ggwParserT__88               = 89
	ggwParserT__89               = 90
	ggwParserWS                  = 91
	ggwParserSINGLE_LINE_COMMENT = 92
	ggwParserMULTI_LINE_COMMENT  = 93
	ggwParserDOC_COMMENT         = 94
	ggwParserINT                 = 95
	ggwParserFLOAT               = 96
	ggwParserBOOL                = 97
	ggwParserSTRING              = 98
	ggwParserIDENTIFIER          = 99
)

// ggwParser rules.
const (
	ggwParserRULE_file                         = 0
	ggwParserRULE_block                        = 1
	ggwParserRULE_statement                    = 2
	ggwParserRULE_expression                   = 3
	ggwParserRULE_logicalExpression            = 4
	ggwParserRULE_comparisonExpression         = 5
	ggwParserRULE_additiveExpression           = 6
	ggwParserRULE_multiplicativeExpression     = 7
	ggwParserRULE_postfixExpression            = 8
	ggwParserRULE_postfixOperator              = 9
	ggwParserRULE_incrementalExpression        = 10
	ggwParserRULE_primaryExpression            = 11
	ggwParserRULE_groupedExpression            = 12
	ggwParserRULE_funcCallExpression           = 13
	ggwParserRULE_funcCallChaining             = 14
	ggwParserRULE_arrayExpression              = 15
	ggwParserRULE_mapExpression                = 16
	ggwParserRULE_onStatement                  = 17
	ggwParserRULE_moduleStatemnt               = 18
	ggwParserRULE_importStatement              = 19
	ggwParserRULE_argument                     = 20
	ggwParserRULE_argumentList                 = 21
	ggwParserRULE_argumentPassList             = 22
	ggwParserRULE_annotation                   = 23
	ggwParserRULE_annotationList               = 24
	ggwParserRULE_annotationArgName            = 25
	ggwParserRULE_annotationArgument           = 26
	ggwParserRULE_annotationDeclaration        = 27
	ggwParserRULE_accessModifier               = 28
	ggwParserRULE_typeDeclaration              = 29
	ggwParserRULE_deconstruct                  = 30
	ggwParserRULE_variableName                 = 31
	ggwParserRULE_variableKind                 = 32
	ggwParserRULE_variableDeclaration          = 33
	ggwParserRULE_variableMultiDeclaration     = 34
	ggwParserRULE_variableClassDeclaration     = 35
	ggwParserRULE_wireKind                     = 36
	ggwParserRULE_wireDeclaration              = 37
	ggwParserRULE_wireAuth                     = 38
	ggwParserRULE_functionDeclaration          = 39
	ggwParserRULE_functionClassDeclaration     = 40
	ggwParserRULE_anonymousFunctionDeclaration = 41
	ggwParserRULE_constructorHeadDeclaration   = 42
	ggwParserRULE_constructorFuncDeclaration   = 43
	ggwParserRULE_enumDeclaration              = 44
	ggwParserRULE_enumProperty                 = 45
	ggwParserRULE_interfaceDeclaration         = 46
	ggwParserRULE_interfaceBodyDeclaration     = 47
	ggwParserRULE_interfaceProperty            = 48
	ggwParserRULE_interfaceFunction            = 49
	ggwParserRULE_classDeclaration             = 50
	ggwParserRULE_classBodyDeclaration         = 51
	ggwParserRULE_ifStatement                  = 52
	ggwParserRULE_whenStatement                = 53
	ggwParserRULE_whenCase                     = 54
	ggwParserRULE_whenCaseBlock                = 55
	ggwParserRULE_forStatement                 = 56
	ggwParserRULE_forIncrementExpression       = 57
	ggwParserRULE_forInStatement               = 58
	ggwParserRULE_whileStatement               = 59
	ggwParserRULE_doWhileStatement             = 60
	ggwParserRULE_grantStatement               = 61
	ggwParserRULE_revokeStatement              = 62
	ggwParserRULE_grantTree                    = 63
	ggwParserRULE_grantTreeBody                = 64
	ggwParserRULE_grantTreeBranch              = 65
	ggwParserRULE_grantTreeInheritance         = 66
	ggwParserRULE_sessionDeclaration           = 67
	ggwParserRULE_sessionBody                  = 68
	ggwParserRULE_sessionProperty              = 69
	ggwParserRULE_type                         = 70
	ggwParserRULE_primitiveType                = 71
	ggwParserRULE_arrayType                    = 72
	ggwParserRULE_mapType                      = 73
	ggwParserRULE_tupleType                    = 74
	ggwParserRULE_genericTypeDeclaration       = 75
	ggwParserRULE_genericDeclaration           = 76
	ggwParserRULE_genericUsage                 = 77
	ggwParserRULE_identifierUsage              = 78
	ggwParserRULE_extends                      = 79
	ggwParserRULE_interfaceExtends             = 80
	ggwParserRULE_implements                   = 81
)

// IFileContext is an interface to support dynamic dispatch.
type IFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsFileContext differentiates from other interfaces.
	IsFileContext()
}

type FileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileContext() *FileContext {
	var p = new(FileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_file
	return p
}

func InitEmptyFileContext(p *FileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_file
}

func (*FileContext) IsFileContext() {}

func NewFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileContext {
	var p = new(FileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_file

	return p
}

func (s *FileContext) GetParser() antlr.Parser { return s.parser }

func (s *FileContext) EOF() antlr.TerminalNode {
	return s.GetToken(ggwParserEOF, 0)
}

func (s *FileContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *FileContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *FileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterFile(s)
	}
}

func (s *FileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitFile(s)
	}
}

func (s *FileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) File() (localctx IFileContext) {
	localctx = NewFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, ggwParserRULE_file)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(167)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-855750919902461832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34376657833) != 0) {
		{
			p.SetState(164)
			p.Statement()
		}

		p.SetState(169)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(170)
		p.Match(ggwParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBlockContext is an interface to support dynamic dispatch.
type IBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsBlockContext differentiates from other interfaces.
	IsBlockContext()
}

type BlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContext() *BlockContext {
	var p = new(BlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_block
	return p
}

func InitEmptyBlockContext(p *BlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_block
}

func (*BlockContext) IsBlockContext() {}

func NewBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContext {
	var p = new(BlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_block

	return p
}

func (s *BlockContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *BlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterBlock(s)
	}
}

func (s *BlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitBlock(s)
	}
}

func (s *BlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Block() (localctx IBlockContext) {
	localctx = NewBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, ggwParserRULE_block)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(172)
		p.Match(ggwParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(176)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-855750919902461832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34376657833) != 0) {
		{
			p.SetState(173)
			p.Statement()
		}

		p.SetState(178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(179)
		p.Match(ggwParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OnStatement() IOnStatementContext
	ModuleStatemnt() IModuleStatemntContext
	ImportStatement() IImportStatementContext
	VariableDeclaration() IVariableDeclarationContext
	VariableMultiDeclaration() IVariableMultiDeclarationContext
	FunctionDeclaration() IFunctionDeclarationContext
	ConstructorFuncDeclaration() IConstructorFuncDeclarationContext
	AnnotationDeclaration() IAnnotationDeclarationContext
	EnumDeclaration() IEnumDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	IfStatement() IIfStatementContext
	ForStatement() IForStatementContext
	ForInStatement() IForInStatementContext
	WhileStatement() IWhileStatementContext
	DoWhileStatement() IDoWhileStatementContext
	WhenStatement() IWhenStatementContext
	FuncCallExpression() IFuncCallExpressionContext
	IncrementalExpression() IIncrementalExpressionContext
	GrantStatement() IGrantStatementContext
	RevokeStatement() IRevokeStatementContext
	GrantTree() IGrantTreeContext
	SessionDeclaration() ISessionDeclarationContext
	Expression() IExpressionContext
	INT() antlr.TerminalNode

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) OnStatement() IOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnStatementContext)
}

func (s *StatementContext) ModuleStatemnt() IModuleStatemntContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModuleStatemntContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModuleStatemntContext)
}

func (s *StatementContext) ImportStatement() IImportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportStatementContext)
}

func (s *StatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *StatementContext) VariableMultiDeclaration() IVariableMultiDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableMultiDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableMultiDeclarationContext)
}

func (s *StatementContext) FunctionDeclaration() IFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDeclarationContext)
}

func (s *StatementContext) ConstructorFuncDeclaration() IConstructorFuncDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorFuncDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorFuncDeclarationContext)
}

func (s *StatementContext) AnnotationDeclaration() IAnnotationDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationDeclarationContext)
}

func (s *StatementContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *StatementContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *StatementContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) ForStatement() IForStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForStatementContext)
}

func (s *StatementContext) ForInStatement() IForInStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForInStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForInStatementContext)
}

func (s *StatementContext) WhileStatement() IWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhileStatementContext)
}

func (s *StatementContext) DoWhileStatement() IDoWhileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDoWhileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDoWhileStatementContext)
}

func (s *StatementContext) WhenStatement() IWhenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenStatementContext)
}

func (s *StatementContext) FuncCallExpression() IFuncCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncCallExpressionContext)
}

func (s *StatementContext) IncrementalExpression() IIncrementalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncrementalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncrementalExpressionContext)
}

func (s *StatementContext) GrantStatement() IGrantStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantStatementContext)
}

func (s *StatementContext) RevokeStatement() IRevokeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeStatementContext)
}

func (s *StatementContext) GrantTree() IGrantTreeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantTreeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantTreeContext)
}

func (s *StatementContext) SessionDeclaration() ISessionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionDeclarationContext)
}

func (s *StatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) INT() antlr.TerminalNode {
	return s.GetToken(ggwParserINT, 0)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, ggwParserRULE_statement)
	var _la int

	p.SetState(226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(181)
			p.OnStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(182)
			p.ModuleStatemnt()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(183)
			p.ImportStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(184)
			p.VariableDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(185)
			p.VariableMultiDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(186)
			p.FunctionDeclaration()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(187)
			p.ConstructorFuncDeclaration()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(188)
			p.AnnotationDeclaration()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(189)
			p.EnumDeclaration()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(190)
			p.InterfaceDeclaration()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(191)
			p.ClassDeclaration()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(192)
			p.IfStatement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(193)
			p.ForStatement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(194)
			p.ForInStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(195)
			p.WhileStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(196)
			p.DoWhileStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(197)
			p.WhenStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(198)
			p.FuncCallExpression()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(199)
			p.IncrementalExpression()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(200)
			p.GrantStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(201)
			p.RevokeStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(202)
			p.GrantTree()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(203)
			p.SessionDeclaration()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(204)
			p.Match(ggwParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(206)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(205)
				p.Expression()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(209)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(208)
				p.Match(ggwParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(211)
			p.Match(ggwParserT__4)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(213)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ggwParserINT {
			{
				p.SetState(212)
				p.Match(ggwParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(216)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(215)
				p.Match(ggwParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(218)
			p.Match(ggwParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(220)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ggwParserINT {
			{
				p.SetState(219)
				p.Match(ggwParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(223)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(222)
				p.Match(ggwParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(225)
			p.Match(ggwParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LogicalExpression() ILogicalExpressionContext
	AnonymousFunctionDeclaration() IAnonymousFunctionDeclarationContext

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) LogicalExpression() ILogicalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILogicalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILogicalExpressionContext)
}

func (s *ExpressionContext) AnonymousFunctionDeclaration() IAnonymousFunctionDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnonymousFunctionDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnonymousFunctionDeclarationContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (s *ExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, ggwParserRULE_expression)
	p.SetState(230)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(228)
			p.LogicalExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(229)
			p.AnonymousFunctionDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogicalExpressionContext is an interface to support dynamic dispatch.
type ILogicalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllComparisonExpression() []IComparisonExpressionContext
	ComparisonExpression(i int) IComparisonExpressionContext

	// IsLogicalExpressionContext differentiates from other interfaces.
	IsLogicalExpressionContext()
}

type LogicalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogicalExpressionContext() *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_logicalExpression
	return p
}

func InitEmptyLogicalExpressionContext(p *LogicalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_logicalExpression
}

func (*LogicalExpressionContext) IsLogicalExpressionContext() {}

func NewLogicalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogicalExpressionContext {
	var p = new(LogicalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_logicalExpression

	return p
}

func (s *LogicalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LogicalExpressionContext) AllComparisonExpression() []IComparisonExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComparisonExpressionContext); ok {
			len++
		}
	}

	tst := make([]IComparisonExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComparisonExpressionContext); ok {
			tst[i] = t.(IComparisonExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalExpressionContext) ComparisonExpression(i int) IComparisonExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonExpressionContext)
}

func (s *LogicalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogicalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitLogicalExpression(s)
	}
}

func (s *LogicalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitLogicalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) LogicalExpression() (localctx ILogicalExpressionContext) {
	localctx = NewLogicalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, ggwParserRULE_logicalExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(232)
		p.ComparisonExpression()
	}
	p.SetState(237)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(233)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ggwParserT__6 || _la == ggwParserT__7) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(234)
				p.ComparisonExpression()
			}

		}
		p.SetState(239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonExpressionContext is an interface to support dynamic dispatch.
type IComparisonExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAdditiveExpression() []IAdditiveExpressionContext
	AdditiveExpression(i int) IAdditiveExpressionContext

	// IsComparisonExpressionContext differentiates from other interfaces.
	IsComparisonExpressionContext()
}

type ComparisonExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonExpressionContext() *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_comparisonExpression
	return p
}

func InitEmptyComparisonExpressionContext(p *ComparisonExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_comparisonExpression
}

func (*ComparisonExpressionContext) IsComparisonExpressionContext() {}

func NewComparisonExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonExpressionContext {
	var p = new(ComparisonExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_comparisonExpression

	return p
}

func (s *ComparisonExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonExpressionContext) AllAdditiveExpression() []IAdditiveExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			len++
		}
	}

	tst := make([]IAdditiveExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAdditiveExpressionContext); ok {
			tst[i] = t.(IAdditiveExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ComparisonExpressionContext) AdditiveExpression(i int) IAdditiveExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdditiveExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdditiveExpressionContext)
}

func (s *ComparisonExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitComparisonExpression(s)
	}
}

func (s *ComparisonExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitComparisonExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ComparisonExpression() (localctx IComparisonExpressionContext) {
	localctx = NewComparisonExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, ggwParserRULE_comparisonExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(240)
		p.AdditiveExpression()
	}
	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(241)
				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&32256) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(242)
				p.AdditiveExpression()
			}

		}
		p.SetState(247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 11, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdditiveExpressionContext is an interface to support dynamic dispatch.
type IAdditiveExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMultiplicativeExpression() []IMultiplicativeExpressionContext
	MultiplicativeExpression(i int) IMultiplicativeExpressionContext

	// IsAdditiveExpressionContext differentiates from other interfaces.
	IsAdditiveExpressionContext()
}

type AdditiveExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdditiveExpressionContext() *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_additiveExpression
	return p
}

func InitEmptyAdditiveExpressionContext(p *AdditiveExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_additiveExpression
}

func (*AdditiveExpressionContext) IsAdditiveExpressionContext() {}

func NewAdditiveExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdditiveExpressionContext {
	var p = new(AdditiveExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_additiveExpression

	return p
}

func (s *AdditiveExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdditiveExpressionContext) AllMultiplicativeExpression() []IMultiplicativeExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMultiplicativeExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplicativeExpressionContext); ok {
			tst[i] = t.(IMultiplicativeExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AdditiveExpressionContext) MultiplicativeExpression(i int) IMultiplicativeExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplicativeExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplicativeExpressionContext)
}

func (s *AdditiveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditiveExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdditiveExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAdditiveExpression(s)
	}
}

func (s *AdditiveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAdditiveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) AdditiveExpression() (localctx IAdditiveExpressionContext) {
	localctx = NewAdditiveExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, ggwParserRULE_additiveExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(248)
		p.MultiplicativeExpression()
	}
	p.SetState(253)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(249)
				_la = p.GetTokenStream().LA(1)

				if !(_la == ggwParserT__14 || _la == ggwParserT__15) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(250)
				p.MultiplicativeExpression()
			}

		}
		p.SetState(255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 12, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiplicativeExpressionContext is an interface to support dynamic dispatch.
type IMultiplicativeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPostfixExpression() []IPostfixExpressionContext
	PostfixExpression(i int) IPostfixExpressionContext

	// IsMultiplicativeExpressionContext differentiates from other interfaces.
	IsMultiplicativeExpressionContext()
}

type MultiplicativeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplicativeExpressionContext() *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_multiplicativeExpression
	return p
}

func InitEmptyMultiplicativeExpressionContext(p *MultiplicativeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_multiplicativeExpression
}

func (*MultiplicativeExpressionContext) IsMultiplicativeExpressionContext() {}

func NewMultiplicativeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplicativeExpressionContext {
	var p = new(MultiplicativeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_multiplicativeExpression

	return p
}

func (s *MultiplicativeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplicativeExpressionContext) AllPostfixExpression() []IPostfixExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPostfixExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixExpressionContext); ok {
			tst[i] = t.(IPostfixExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicativeExpressionContext) PostfixExpression(i int) IPostfixExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixExpressionContext)
}

func (s *MultiplicativeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicativeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplicativeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitMultiplicativeExpression(s)
	}
}

func (s *MultiplicativeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitMultiplicativeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) MultiplicativeExpression() (localctx IMultiplicativeExpressionContext) {
	localctx = NewMultiplicativeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, ggwParserRULE_multiplicativeExpression)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(256)
		p.PostfixExpression()
	}
	p.SetState(261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(257)
				_la = p.GetTokenStream().LA(1)

				if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&917504) != 0) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(258)
				p.PostfixExpression()
			}

		}
		p.SetState(263)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 13, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixExpressionContext is an interface to support dynamic dispatch.
type IPostfixExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimaryExpression() IPrimaryExpressionContext
	AllPostfixOperator() []IPostfixOperatorContext
	PostfixOperator(i int) IPostfixOperatorContext

	// IsPostfixExpressionContext differentiates from other interfaces.
	IsPostfixExpressionContext()
}

type PostfixExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixExpressionContext() *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_postfixExpression
	return p
}

func InitEmptyPostfixExpressionContext(p *PostfixExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_postfixExpression
}

func (*PostfixExpressionContext) IsPostfixExpressionContext() {}

func NewPostfixExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixExpressionContext {
	var p = new(PostfixExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_postfixExpression

	return p
}

func (s *PostfixExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PostfixExpressionContext) AllPostfixOperator() []IPostfixOperatorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPostfixOperatorContext); ok {
			len++
		}
	}

	tst := make([]IPostfixOperatorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPostfixOperatorContext); ok {
			tst[i] = t.(IPostfixOperatorContext)
			i++
		}
	}

	return tst
}

func (s *PostfixExpressionContext) PostfixOperator(i int) IPostfixOperatorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPostfixOperatorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPostfixOperatorContext)
}

func (s *PostfixExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitPostfixExpression(s)
	}
}

func (s *PostfixExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitPostfixExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) PostfixExpression() (localctx IPostfixExpressionContext) {
	localctx = NewPostfixExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, ggwParserRULE_postfixExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(264)
		p.PrimaryExpression()
	}
	p.SetState(268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(265)
				p.PostfixOperator()
			}

		}
		p.SetState(270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPostfixOperatorContext is an interface to support dynamic dispatch.
type IPostfixOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	FuncCallChaining() IFuncCallChainingContext

	// IsPostfixOperatorContext differentiates from other interfaces.
	IsPostfixOperatorContext()
}

type PostfixOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPostfixOperatorContext() *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_postfixOperator
	return p
}

func InitEmptyPostfixOperatorContext(p *PostfixOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_postfixOperator
}

func (*PostfixOperatorContext) IsPostfixOperatorContext() {}

func NewPostfixOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PostfixOperatorContext {
	var p = new(PostfixOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_postfixOperator

	return p
}

func (s *PostfixOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *PostfixOperatorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PostfixOperatorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PostfixOperatorContext) FuncCallChaining() IFuncCallChainingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncCallChainingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncCallChainingContext)
}

func (s *PostfixOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PostfixOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PostfixOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterPostfixOperator(s)
	}
}

func (s *PostfixOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitPostfixOperator(s)
	}
}

func (s *PostfixOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitPostfixOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) PostfixOperator() (localctx IPostfixOperatorContext) {
	localctx = NewPostfixOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, ggwParserRULE_postfixOperator)
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserT__19:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(271)
			p.Match(ggwParserT__19)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(272)
			p.Expression()
		}
		{
			p.SetState(273)
			p.Match(ggwParserT__20)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ggwParserT__21:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(275)
			p.Match(ggwParserT__21)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(276)
			p.Expression()
		}
		{
			p.SetState(277)
			p.Match(ggwParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(278)
			p.Expression()
		}

	case ggwParserT__33:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(280)
			p.FuncCallChaining()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIncrementalExpressionContext is an interface to support dynamic dispatch.
type IIncrementalExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsIncrementalExpressionContext differentiates from other interfaces.
	IsIncrementalExpressionContext()
}

type IncrementalExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncrementalExpressionContext() *IncrementalExpressionContext {
	var p = new(IncrementalExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_incrementalExpression
	return p
}

func InitEmptyIncrementalExpressionContext(p *IncrementalExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_incrementalExpression
}

func (*IncrementalExpressionContext) IsIncrementalExpressionContext() {}

func NewIncrementalExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncrementalExpressionContext {
	var p = new(IncrementalExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_incrementalExpression

	return p
}

func (s *IncrementalExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *IncrementalExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *IncrementalExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IncrementalExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncrementalExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IncrementalExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterIncrementalExpression(s)
	}
}

func (s *IncrementalExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitIncrementalExpression(s)
	}
}

func (s *IncrementalExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitIncrementalExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) IncrementalExpression() (localctx IIncrementalExpressionContext) {
	localctx = NewIncrementalExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, ggwParserRULE_incrementalExpression)
	var _la int

	p.SetState(290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(283)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ggwParserT__23 || _la == ggwParserT__24) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(284)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(285)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(286)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ggwParserT__23 || _la == ggwParserT__24) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(287)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(288)
			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2080374784) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(289)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	STRING() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	GroupedExpression() IGroupedExpressionContext
	FuncCallExpression() IFuncCallExpressionContext
	WhenStatement() IWhenStatementContext
	ArrayExpression() IArrayExpressionContext
	MapExpression() IMapExpressionContext
	IdentifierUsage() IIdentifierUsageContext
	IncrementalExpression() IIncrementalExpressionContext

	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) INT() antlr.TerminalNode {
	return s.GetToken(ggwParserINT, 0)
}

func (s *PrimaryExpressionContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ggwParserFLOAT, 0)
}

func (s *PrimaryExpressionContext) BOOL() antlr.TerminalNode {
	return s.GetToken(ggwParserBOOL, 0)
}

func (s *PrimaryExpressionContext) STRING() antlr.TerminalNode {
	return s.GetToken(ggwParserSTRING, 0)
}

func (s *PrimaryExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *PrimaryExpressionContext) GroupedExpression() IGroupedExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupedExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupedExpressionContext)
}

func (s *PrimaryExpressionContext) FuncCallExpression() IFuncCallExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFuncCallExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFuncCallExpressionContext)
}

func (s *PrimaryExpressionContext) WhenStatement() IWhenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenStatementContext)
}

func (s *PrimaryExpressionContext) ArrayExpression() IArrayExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayExpressionContext)
}

func (s *PrimaryExpressionContext) MapExpression() IMapExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionContext)
}

func (s *PrimaryExpressionContext) IdentifierUsage() IIdentifierUsageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierUsageContext)
}

func (s *PrimaryExpressionContext) IncrementalExpression() IIncrementalExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncrementalExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncrementalExpressionContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitPrimaryExpression(s)
	}
}

func (s *PrimaryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitPrimaryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, ggwParserRULE_primaryExpression)
	p.SetState(304)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(292)
			p.Match(ggwParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(293)
			p.Match(ggwParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(294)
			p.Match(ggwParserBOOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(295)
			p.Match(ggwParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(296)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(297)
			p.GroupedExpression()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(298)
			p.FuncCallExpression()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(299)
			p.WhenStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(300)
			p.ArrayExpression()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(301)
			p.MapExpression()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(302)
			p.IdentifierUsage()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(303)
			p.IncrementalExpression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupedExpressionContext is an interface to support dynamic dispatch.
type IGroupedExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsGroupedExpressionContext differentiates from other interfaces.
	IsGroupedExpressionContext()
}

type GroupedExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupedExpressionContext() *GroupedExpressionContext {
	var p = new(GroupedExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_groupedExpression
	return p
}

func InitEmptyGroupedExpressionContext(p *GroupedExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_groupedExpression
}

func (*GroupedExpressionContext) IsGroupedExpressionContext() {}

func NewGroupedExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupedExpressionContext {
	var p = new(GroupedExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_groupedExpression

	return p
}

func (s *GroupedExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupedExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGroupedExpression(s)
	}
}

func (s *GroupedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGroupedExpression(s)
	}
}

func (s *GroupedExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGroupedExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GroupedExpression() (localctx IGroupedExpressionContext) {
	localctx = NewGroupedExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, ggwParserRULE_groupedExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(306)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(307)
		p.Expression()
	}
	{
		p.SetState(308)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncCallExpressionContext is an interface to support dynamic dispatch.
type IFuncCallExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierUsage() IIdentifierUsageContext
	ArgumentPassList() IArgumentPassListContext

	// IsFuncCallExpressionContext differentiates from other interfaces.
	IsFuncCallExpressionContext()
}

type FuncCallExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncCallExpressionContext() *FuncCallExpressionContext {
	var p = new(FuncCallExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_funcCallExpression
	return p
}

func InitEmptyFuncCallExpressionContext(p *FuncCallExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_funcCallExpression
}

func (*FuncCallExpressionContext) IsFuncCallExpressionContext() {}

func NewFuncCallExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncCallExpressionContext {
	var p = new(FuncCallExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_funcCallExpression

	return p
}

func (s *FuncCallExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncCallExpressionContext) IdentifierUsage() IIdentifierUsageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierUsageContext)
}

func (s *FuncCallExpressionContext) ArgumentPassList() IArgumentPassListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentPassListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentPassListContext)
}

func (s *FuncCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncCallExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterFuncCallExpression(s)
	}
}

func (s *FuncCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitFuncCallExpression(s)
	}
}

func (s *FuncCallExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitFuncCallExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) FuncCallExpression() (localctx IFuncCallExpressionContext) {
	localctx = NewFuncCallExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, ggwParserRULE_funcCallExpression)
	var _la int

	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserT__87, ggwParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(310)
			p.IdentifierUsage()
		}
		{
			p.SetState(311)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&10788798464) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&8323596289) != 0) {
			{
				p.SetState(312)
				p.ArgumentPassList()
			}

		}
		{
			p.SetState(315)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ggwParserT__32:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(317)
			p.Match(ggwParserT__32)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(318)
			p.IdentifierUsage()
		}
		{
			p.SetState(319)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&10788798464) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&8323596289) != 0) {
			{
				p.SetState(320)
				p.ArgumentPassList()
			}

		}
		{
			p.SetState(323)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFuncCallChainingContext is an interface to support dynamic dispatch.
type IFuncCallChainingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierUsage() IIdentifierUsageContext
	ArgumentPassList() IArgumentPassListContext

	// IsFuncCallChainingContext differentiates from other interfaces.
	IsFuncCallChainingContext()
}

type FuncCallChainingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFuncCallChainingContext() *FuncCallChainingContext {
	var p = new(FuncCallChainingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_funcCallChaining
	return p
}

func InitEmptyFuncCallChainingContext(p *FuncCallChainingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_funcCallChaining
}

func (*FuncCallChainingContext) IsFuncCallChainingContext() {}

func NewFuncCallChainingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FuncCallChainingContext {
	var p = new(FuncCallChainingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_funcCallChaining

	return p
}

func (s *FuncCallChainingContext) GetParser() antlr.Parser { return s.parser }

func (s *FuncCallChainingContext) IdentifierUsage() IIdentifierUsageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierUsageContext)
}

func (s *FuncCallChainingContext) ArgumentPassList() IArgumentPassListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentPassListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentPassListContext)
}

func (s *FuncCallChainingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FuncCallChainingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FuncCallChainingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterFuncCallChaining(s)
	}
}

func (s *FuncCallChainingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitFuncCallChaining(s)
	}
}

func (s *FuncCallChainingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitFuncCallChaining(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) FuncCallChaining() (localctx IFuncCallChainingContext) {
	localctx = NewFuncCallChainingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, ggwParserRULE_funcCallChaining)
	var _la int

	p.SetState(337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(327)
			p.Match(ggwParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(328)
			p.IdentifierUsage()
		}
		{
			p.SetState(329)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(331)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&10788798464) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&8323596289) != 0) {
			{
				p.SetState(330)
				p.ArgumentPassList()
			}

		}
		{
			p.SetState(333)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(335)
			p.Match(ggwParserT__33)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(336)
			p.IdentifierUsage()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayExpressionContext is an interface to support dynamic dispatch.
type IArrayExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsArrayExpressionContext differentiates from other interfaces.
	IsArrayExpressionContext()
}

type ArrayExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayExpressionContext() *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_arrayExpression
	return p
}

func InitEmptyArrayExpressionContext(p *ArrayExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_arrayExpression
}

func (*ArrayExpressionContext) IsArrayExpressionContext() {}

func NewArrayExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayExpressionContext {
	var p = new(ArrayExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_arrayExpression

	return p
}

func (s *ArrayExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArrayExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArrayExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterArrayExpression(s)
	}
}

func (s *ArrayExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitArrayExpression(s)
	}
}

func (s *ArrayExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitArrayExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ArrayExpression() (localctx IArrayExpressionContext) {
	localctx = NewArrayExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, ggwParserRULE_arrayExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(339)
		p.Match(ggwParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(340)
		p.Expression()
	}
	p.SetState(345)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(341)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(342)
			p.Expression()
		}

		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(348)
		p.Match(ggwParserT__20)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionContext is an interface to support dynamic dispatch.
type IMapExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsMapExpressionContext differentiates from other interfaces.
	IsMapExpressionContext()
}

type MapExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExpressionContext() *MapExpressionContext {
	var p = new(MapExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_mapExpression
	return p
}

func InitEmptyMapExpressionContext(p *MapExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_mapExpression
}

func (*MapExpressionContext) IsMapExpressionContext() {}

func NewMapExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionContext {
	var p = new(MapExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_mapExpression

	return p
}

func (s *MapExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterMapExpression(s)
	}
}

func (s *MapExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitMapExpression(s)
	}
}

func (s *MapExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitMapExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) MapExpression() (localctx IMapExpressionContext) {
	localctx = NewMapExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, ggwParserRULE_mapExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(350)
		p.Match(ggwParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(351)
		p.Expression()
	}
	{
		p.SetState(352)
		p.Match(ggwParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(353)
		p.Expression()
	}
	p.SetState(361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(354)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(355)
			p.Expression()
		}
		{
			p.SetState(356)
			p.Match(ggwParserT__22)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(357)
			p.Expression()
		}

		p.SetState(363)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(364)
		p.Match(ggwParserT__20)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnStatementContext is an interface to support dynamic dispatch.
type IOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOnStatementContext differentiates from other interfaces.
	IsOnStatementContext()
}

type OnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnStatementContext() *OnStatementContext {
	var p = new(OnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_onStatement
	return p
}

func InitEmptyOnStatementContext(p *OnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_onStatement
}

func (*OnStatementContext) IsOnStatementContext() {}

func NewOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnStatementContext {
	var p = new(OnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_onStatement

	return p
}

func (s *OnStatementContext) GetParser() antlr.Parser { return s.parser }
func (s *OnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterOnStatement(s)
	}
}

func (s *OnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitOnStatement(s)
	}
}

func (s *OnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitOnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) OnStatement() (localctx IOnStatementContext) {
	localctx = NewOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, ggwParserRULE_onStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Match(ggwParserT__35)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(367)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&962072674304) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModuleStatemntContext is an interface to support dynamic dispatch.
type IModuleStatemntContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	OnStatement() IOnStatementContext

	// IsModuleStatemntContext differentiates from other interfaces.
	IsModuleStatemntContext()
}

type ModuleStatemntContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleStatemntContext() *ModuleStatemntContext {
	var p = new(ModuleStatemntContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_moduleStatemnt
	return p
}

func InitEmptyModuleStatemntContext(p *ModuleStatemntContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_moduleStatemnt
}

func (*ModuleStatemntContext) IsModuleStatemntContext() {}

func NewModuleStatemntContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleStatemntContext {
	var p = new(ModuleStatemntContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_moduleStatemnt

	return p
}

func (s *ModuleStatemntContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleStatemntContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *ModuleStatemntContext) OnStatement() IOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnStatementContext)
}

func (s *ModuleStatemntContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleStatemntContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleStatemntContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterModuleStatemnt(s)
	}
}

func (s *ModuleStatemntContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitModuleStatemnt(s)
	}
}

func (s *ModuleStatemntContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitModuleStatemnt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ModuleStatemnt() (localctx IModuleStatemntContext) {
	localctx = NewModuleStatemntContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, ggwParserRULE_moduleStatemnt)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(369)
		p.Match(ggwParserT__39)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(370)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(372)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 25, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(371)
			p.OnStatement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportStatementContext is an interface to support dynamic dispatch.
type IImportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode
	STRING() antlr.TerminalNode

	// IsImportStatementContext differentiates from other interfaces.
	IsImportStatementContext()
}

type ImportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportStatementContext() *ImportStatementContext {
	var p = new(ImportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_importStatement
	return p
}

func InitEmptyImportStatementContext(p *ImportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_importStatement
}

func (*ImportStatementContext) IsImportStatementContext() {}

func NewImportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportStatementContext {
	var p = new(ImportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_importStatement

	return p
}

func (s *ImportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportStatementContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ggwParserIDENTIFIER)
}

func (s *ImportStatementContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, i)
}

func (s *ImportStatementContext) STRING() antlr.TerminalNode {
	return s.GetToken(ggwParserSTRING, 0)
}

func (s *ImportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterImportStatement(s)
	}
}

func (s *ImportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitImportStatement(s)
	}
}

func (s *ImportStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitImportStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ImportStatement() (localctx IImportStatementContext) {
	localctx = NewImportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, ggwParserRULE_importStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(374)
		p.Match(ggwParserT__40)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(375)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__41 {
		{
			p.SetState(376)
			p.Match(ggwParserT__41)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(377)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(382)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__42 {
		{
			p.SetState(380)
			p.Match(ggwParserT__42)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(381)
			p.Match(ggwParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	TypeDeclaration() ITypeDeclarationContext
	Expression() IExpressionContext

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_argument
	return p
}

func InitEmptyArgumentContext(p *ArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_argument
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *ArgumentContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *ArgumentContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Argument() (localctx IArgumentContext) {
	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, ggwParserRULE_argument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(384)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__22 {
		{
			p.SetState(385)
			p.TypeDeclaration()
		}

	}
	p.SetState(390)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__43 {
		{
			p.SetState(388)
			p.Match(ggwParserT__43)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(389)
			p.Expression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllArgument() []IArgumentContext
	Argument(i int) IArgumentContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentListContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (s *ArgumentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitArgumentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, ggwParserRULE_argumentList)
	var _la int

	var _alt int

	p.SetState(407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(392)
			p.Argument()
		}
		p.SetState(397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(393)
					p.Match(ggwParserT__34)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(394)
					p.Argument()
				}

			}
			p.SetState(399)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 30, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(403)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ggwParserT__34 {
			{
				p.SetState(400)
				p.Match(ggwParserT__34)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(401)
				p.Match(ggwParserT__44)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(402)
				p.Argument()
			}

		}

	case ggwParserT__44:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(405)
			p.Match(ggwParserT__44)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(406)
			p.Argument()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentPassListContext is an interface to support dynamic dispatch.
type IArgumentPassListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsArgumentPassListContext differentiates from other interfaces.
	IsArgumentPassListContext()
}

type ArgumentPassListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentPassListContext() *ArgumentPassListContext {
	var p = new(ArgumentPassListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_argumentPassList
	return p
}

func InitEmptyArgumentPassListContext(p *ArgumentPassListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_argumentPassList
}

func (*ArgumentPassListContext) IsArgumentPassListContext() {}

func NewArgumentPassListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentPassListContext {
	var p = new(ArgumentPassListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_argumentPassList

	return p
}

func (s *ArgumentPassListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentPassListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArgumentPassListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ArgumentPassListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentPassListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentPassListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterArgumentPassList(s)
	}
}

func (s *ArgumentPassListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitArgumentPassList(s)
	}
}

func (s *ArgumentPassListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitArgumentPassList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ArgumentPassList() (localctx IArgumentPassListContext) {
	localctx = NewArgumentPassListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, ggwParserRULE_argumentPassList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Expression()
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(410)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(411)
			p.Expression()
		}

		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationContext is an interface to support dynamic dispatch.
type IAnnotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AllAnnotationArgument() []IAnnotationArgumentContext
	AnnotationArgument(i int) IAnnotationArgumentContext

	// IsAnnotationContext differentiates from other interfaces.
	IsAnnotationContext()
}

type AnnotationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationContext() *AnnotationContext {
	var p = new(AnnotationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotation
	return p
}

func InitEmptyAnnotationContext(p *AnnotationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotation
}

func (*AnnotationContext) IsAnnotationContext() {}

func NewAnnotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationContext {
	var p = new(AnnotationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_annotation

	return p
}

func (s *AnnotationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *AnnotationContext) AllAnnotationArgument() []IAnnotationArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationArgumentContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationArgumentContext); ok {
			tst[i] = t.(IAnnotationArgumentContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationContext) AnnotationArgument(i int) IAnnotationArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationArgumentContext)
}

func (s *AnnotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAnnotation(s)
	}
}

func (s *AnnotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAnnotation(s)
	}
}

func (s *AnnotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAnnotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Annotation() (localctx IAnnotationContext) {
	localctx = NewAnnotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, ggwParserRULE_annotation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		p.Match(ggwParserT__45)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(418)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(431)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 36, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(419)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(428)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&31) != 0 {
			{
				p.SetState(420)
				p.AnnotationArgument()
			}
			p.SetState(425)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ggwParserT__34 {
				{
					p.SetState(421)
					p.Match(ggwParserT__34)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(422)
					p.AnnotationArgument()
				}

				p.SetState(427)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(430)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationListContext is an interface to support dynamic dispatch.
type IAnnotationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAnnotation() []IAnnotationContext
	Annotation(i int) IAnnotationContext

	// IsAnnotationListContext differentiates from other interfaces.
	IsAnnotationListContext()
}

type AnnotationListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationListContext() *AnnotationListContext {
	var p = new(AnnotationListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationList
	return p
}

func InitEmptyAnnotationListContext(p *AnnotationListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationList
}

func (*AnnotationListContext) IsAnnotationListContext() {}

func NewAnnotationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationListContext {
	var p = new(AnnotationListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_annotationList

	return p
}

func (s *AnnotationListContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationListContext) AllAnnotation() []IAnnotationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAnnotationContext); ok {
			len++
		}
	}

	tst := make([]IAnnotationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAnnotationContext); ok {
			tst[i] = t.(IAnnotationContext)
			i++
		}
	}

	return tst
}

func (s *AnnotationListContext) Annotation(i int) IAnnotationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationContext)
}

func (s *AnnotationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAnnotationList(s)
	}
}

func (s *AnnotationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAnnotationList(s)
	}
}

func (s *AnnotationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAnnotationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) AnnotationList() (localctx IAnnotationListContext) {
	localctx = NewAnnotationListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, ggwParserRULE_annotationList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(436)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__45 {
		{
			p.SetState(433)
			p.Annotation()
		}

		p.SetState(438)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationArgNameContext is an interface to support dynamic dispatch.
type IAnnotationArgNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode

	// IsAnnotationArgNameContext differentiates from other interfaces.
	IsAnnotationArgNameContext()
}

type AnnotationArgNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationArgNameContext() *AnnotationArgNameContext {
	var p = new(AnnotationArgNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationArgName
	return p
}

func InitEmptyAnnotationArgNameContext(p *AnnotationArgNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationArgName
}

func (*AnnotationArgNameContext) IsAnnotationArgNameContext() {}

func NewAnnotationArgNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationArgNameContext {
	var p = new(AnnotationArgNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_annotationArgName

	return p
}

func (s *AnnotationArgNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationArgNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *AnnotationArgNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationArgNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationArgNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAnnotationArgName(s)
	}
}

func (s *AnnotationArgNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAnnotationArgName(s)
	}
}

func (s *AnnotationArgNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAnnotationArgName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) AnnotationArgName() (localctx IAnnotationArgNameContext) {
	localctx = NewAnnotationArgNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, ggwParserRULE_annotationArgName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(439)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(440)
		p.Match(ggwParserT__43)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationArgumentContext is an interface to support dynamic dispatch.
type IAnnotationArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	INT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	BOOL() antlr.TerminalNode
	IDENTIFIER() antlr.TerminalNode
	AnnotationArgName() IAnnotationArgNameContext

	// IsAnnotationArgumentContext differentiates from other interfaces.
	IsAnnotationArgumentContext()
}

type AnnotationArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationArgumentContext() *AnnotationArgumentContext {
	var p = new(AnnotationArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationArgument
	return p
}

func InitEmptyAnnotationArgumentContext(p *AnnotationArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationArgument
}

func (*AnnotationArgumentContext) IsAnnotationArgumentContext() {}

func NewAnnotationArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationArgumentContext {
	var p = new(AnnotationArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_annotationArgument

	return p
}

func (s *AnnotationArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationArgumentContext) STRING() antlr.TerminalNode {
	return s.GetToken(ggwParserSTRING, 0)
}

func (s *AnnotationArgumentContext) INT() antlr.TerminalNode {
	return s.GetToken(ggwParserINT, 0)
}

func (s *AnnotationArgumentContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(ggwParserFLOAT, 0)
}

func (s *AnnotationArgumentContext) BOOL() antlr.TerminalNode {
	return s.GetToken(ggwParserBOOL, 0)
}

func (s *AnnotationArgumentContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *AnnotationArgumentContext) AnnotationArgName() IAnnotationArgNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationArgNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationArgNameContext)
}

func (s *AnnotationArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAnnotationArgument(s)
	}
}

func (s *AnnotationArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAnnotationArgument(s)
	}
}

func (s *AnnotationArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAnnotationArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) AnnotationArgument() (localctx IAnnotationArgumentContext) {
	localctx = NewAnnotationArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, ggwParserRULE_annotationArgument)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(443)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(442)
			p.AnnotationArgName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(445)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-95)) & ^0x3f) == 0 && ((int64(1)<<(_la-95))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnnotationDeclarationContext is an interface to support dynamic dispatch.
type IAnnotationDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	ArgumentList() IArgumentListContext

	// IsAnnotationDeclarationContext differentiates from other interfaces.
	IsAnnotationDeclarationContext()
}

type AnnotationDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnnotationDeclarationContext() *AnnotationDeclarationContext {
	var p = new(AnnotationDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationDeclaration
	return p
}

func InitEmptyAnnotationDeclarationContext(p *AnnotationDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_annotationDeclaration
}

func (*AnnotationDeclarationContext) IsAnnotationDeclarationContext() {}

func NewAnnotationDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnnotationDeclarationContext {
	var p = new(AnnotationDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_annotationDeclaration

	return p
}

func (s *AnnotationDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnnotationDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *AnnotationDeclarationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *AnnotationDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnnotationDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnnotationDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAnnotationDeclaration(s)
	}
}

func (s *AnnotationDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAnnotationDeclaration(s)
	}
}

func (s *AnnotationDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAnnotationDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) AnnotationDeclaration() (localctx IAnnotationDeclarationContext) {
	localctx = NewAnnotationDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, ggwParserRULE_annotationDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(447)
		p.Match(ggwParserT__46)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(448)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(449)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(450)
		p.ArgumentList()
	}
	{
		p.SetState(451)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccessModifierContext is an interface to support dynamic dispatch.
type IAccessModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAccessModifierContext differentiates from other interfaces.
	IsAccessModifierContext()
}

type AccessModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModifierContext() *AccessModifierContext {
	var p = new(AccessModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_accessModifier
	return p
}

func InitEmptyAccessModifierContext(p *AccessModifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_accessModifier
}

func (*AccessModifierContext) IsAccessModifierContext() {}

func NewAccessModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModifierContext {
	var p = new(AccessModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_accessModifier

	return p
}

func (s *AccessModifierContext) GetParser() antlr.Parser { return s.parser }
func (s *AccessModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAccessModifier(s)
	}
}

func (s *AccessModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAccessModifier(s)
	}
}

func (s *AccessModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAccessModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) AccessModifier() (localctx IAccessModifierContext) {
	localctx = NewAccessModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, ggwParserRULE_accessModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(453)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDeclarationContext is an interface to support dynamic dispatch.
type ITypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext

	// IsTypeDeclarationContext differentiates from other interfaces.
	IsTypeDeclarationContext()
}

type TypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDeclarationContext() *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_typeDeclaration
	return p
}

func InitEmptyTypeDeclarationContext(p *TypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_typeDeclaration
}

func (*TypeDeclarationContext) IsTypeDeclarationContext() {}

func NewTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDeclarationContext {
	var p = new(TypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_typeDeclaration

	return p
}

func (s *TypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDeclarationContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitTypeDeclaration(s)
	}
}

func (s *TypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) TypeDeclaration() (localctx ITypeDeclarationContext) {
	localctx = NewTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, ggwParserRULE_typeDeclaration)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(455)
		p.Match(ggwParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(456)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeconstructContext is an interface to support dynamic dispatch.
type IDeconstructContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIDENTIFIER() []antlr.TerminalNode
	IDENTIFIER(i int) antlr.TerminalNode

	// IsDeconstructContext differentiates from other interfaces.
	IsDeconstructContext()
}

type DeconstructContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeconstructContext() *DeconstructContext {
	var p = new(DeconstructContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_deconstruct
	return p
}

func InitEmptyDeconstructContext(p *DeconstructContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_deconstruct
}

func (*DeconstructContext) IsDeconstructContext() {}

func NewDeconstructContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeconstructContext {
	var p = new(DeconstructContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_deconstruct

	return p
}

func (s *DeconstructContext) GetParser() antlr.Parser { return s.parser }

func (s *DeconstructContext) AllIDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(ggwParserIDENTIFIER)
}

func (s *DeconstructContext) IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, i)
}

func (s *DeconstructContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeconstructContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeconstructContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterDeconstruct(s)
	}
}

func (s *DeconstructContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitDeconstruct(s)
	}
}

func (s *DeconstructContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitDeconstruct(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Deconstruct() (localctx IDeconstructContext) {
	localctx = NewDeconstructContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, ggwParserRULE_deconstruct)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(458)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(459)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(460)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(461)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(467)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableNameContext is an interface to support dynamic dispatch.
type IVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Deconstruct() IDeconstructContext

	// IsVariableNameContext differentiates from other interfaces.
	IsVariableNameContext()
}

type VariableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableNameContext() *VariableNameContext {
	var p = new(VariableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableName
	return p
}

func InitEmptyVariableNameContext(p *VariableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableName
}

func (*VariableNameContext) IsVariableNameContext() {}

func NewVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableNameContext {
	var p = new(VariableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_variableName

	return p
}

func (s *VariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableNameContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *VariableNameContext) Deconstruct() IDeconstructContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeconstructContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeconstructContext)
}

func (s *VariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterVariableName(s)
	}
}

func (s *VariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitVariableName(s)
	}
}

func (s *VariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) VariableName() (localctx IVariableNameContext) {
	localctx = NewVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, ggwParserRULE_variableName)
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(469)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ggwParserT__30:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(470)
			p.Deconstruct()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableKindContext is an interface to support dynamic dispatch.
type IVariableKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AccessModifier() IAccessModifierContext

	// IsVariableKindContext differentiates from other interfaces.
	IsVariableKindContext()
}

type VariableKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableKindContext() *VariableKindContext {
	var p = new(VariableKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableKind
	return p
}

func InitEmptyVariableKindContext(p *VariableKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableKind
}

func (*VariableKindContext) IsVariableKindContext() {}

func NewVariableKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableKindContext {
	var p = new(VariableKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_variableKind

	return p
}

func (s *VariableKindContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableKindContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *VariableKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterVariableKind(s)
	}
}

func (s *VariableKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitVariableKind(s)
	}
}

func (s *VariableKindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitVariableKind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) VariableKind() (localctx IVariableKindContext) {
	localctx = NewVariableKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, ggwParserRULE_variableKind)
	var _la int

	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserT__47, ggwParserT__48, ggwParserT__49, ggwParserT__50:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0 {
			{
				p.SetState(473)
				p.AccessModifier()
			}

		}
		{
			p.SetState(476)
			p.Match(ggwParserT__50)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ggwParserT__51:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(477)
			p.Match(ggwParserT__51)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableDeclarationContext is an interface to support dynamic dispatch.
type IVariableDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableName() IVariableNameContext
	VariableKind() IVariableKindContext
	TypeDeclaration() ITypeDeclarationContext
	Expression() IExpressionContext
	WireDeclaration() IWireDeclarationContext

	// IsVariableDeclarationContext differentiates from other interfaces.
	IsVariableDeclarationContext()
}

type VariableDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableDeclarationContext() *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableDeclaration
	return p
}

func InitEmptyVariableDeclarationContext(p *VariableDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableDeclaration
}

func (*VariableDeclarationContext) IsVariableDeclarationContext() {}

func NewVariableDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableDeclarationContext {
	var p = new(VariableDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_variableDeclaration

	return p
}

func (s *VariableDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableDeclarationContext) VariableName() IVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *VariableDeclarationContext) VariableKind() IVariableKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableKindContext)
}

func (s *VariableDeclarationContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *VariableDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableDeclarationContext) WireDeclaration() IWireDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWireDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWireDeclarationContext)
}

func (s *VariableDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitVariableDeclaration(s)
	}
}

func (s *VariableDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitVariableDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) VariableDeclaration() (localctx IVariableDeclarationContext) {
	localctx = NewVariableDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, ggwParserRULE_variableDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(481)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8725724278030336) != 0 {
		{
			p.SetState(480)
			p.VariableKind()
		}

	}
	{
		p.SetState(483)
		p.VariableName()
	}
	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__22 {
		{
			p.SetState(484)
			p.TypeDeclaration()
		}

	}
	p.SetState(489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__43 {
		{
			p.SetState(487)
			p.Match(ggwParserT__43)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(488)
			p.Expression()
		}

	}
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__55 {
		{
			p.SetState(491)
			p.WireDeclaration()
		}

	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(494)
			p.Match(ggwParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableMultiDeclarationContext is an interface to support dynamic dispatch.
type IVariableMultiDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableName() []IVariableNameContext
	VariableName(i int) IVariableNameContext
	VariableKind() IVariableKindContext
	TypeDeclaration() ITypeDeclarationContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	WireDeclaration() IWireDeclarationContext

	// IsVariableMultiDeclarationContext differentiates from other interfaces.
	IsVariableMultiDeclarationContext()
}

type VariableMultiDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableMultiDeclarationContext() *VariableMultiDeclarationContext {
	var p = new(VariableMultiDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableMultiDeclaration
	return p
}

func InitEmptyVariableMultiDeclarationContext(p *VariableMultiDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableMultiDeclaration
}

func (*VariableMultiDeclarationContext) IsVariableMultiDeclarationContext() {}

func NewVariableMultiDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableMultiDeclarationContext {
	var p = new(VariableMultiDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_variableMultiDeclaration

	return p
}

func (s *VariableMultiDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableMultiDeclarationContext) AllVariableName() []IVariableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableNameContext); ok {
			len++
		}
	}

	tst := make([]IVariableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableNameContext); ok {
			tst[i] = t.(IVariableNameContext)
			i++
		}
	}

	return tst
}

func (s *VariableMultiDeclarationContext) VariableName(i int) IVariableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *VariableMultiDeclarationContext) VariableKind() IVariableKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableKindContext)
}

func (s *VariableMultiDeclarationContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *VariableMultiDeclarationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *VariableMultiDeclarationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *VariableMultiDeclarationContext) WireDeclaration() IWireDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWireDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWireDeclarationContext)
}

func (s *VariableMultiDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableMultiDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableMultiDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterVariableMultiDeclaration(s)
	}
}

func (s *VariableMultiDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitVariableMultiDeclaration(s)
	}
}

func (s *VariableMultiDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitVariableMultiDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) VariableMultiDeclaration() (localctx IVariableMultiDeclarationContext) {
	localctx = NewVariableMultiDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, ggwParserRULE_variableMultiDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8725724278030336) != 0 {
		{
			p.SetState(497)
			p.VariableKind()
		}

	}
	{
		p.SetState(500)
		p.VariableName()
	}
	p.SetState(505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(501)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(502)
			p.VariableName()
		}

		p.SetState(507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__22 {
		{
			p.SetState(508)
			p.TypeDeclaration()
		}

	}
	p.SetState(520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__43 {
		{
			p.SetState(511)
			p.Match(ggwParserT__43)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(512)
			p.Expression()
		}
		p.SetState(517)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ggwParserT__34 {
			{
				p.SetState(513)
				p.Match(ggwParserT__34)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(514)
				p.Expression()
			}

			p.SetState(519)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__55 {
		{
			p.SetState(522)
			p.WireDeclaration()
		}

	}
	p.SetState(526)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(525)
			p.Match(ggwParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableClassDeclarationContext is an interface to support dynamic dispatch.
type IVariableClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableDeclaration() IVariableDeclarationContext
	VariableMultiDeclaration() IVariableMultiDeclarationContext
	AnnotationList() IAnnotationListContext
	AccessModifier() IAccessModifierContext

	// IsVariableClassDeclarationContext differentiates from other interfaces.
	IsVariableClassDeclarationContext()
}

type VariableClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableClassDeclarationContext() *VariableClassDeclarationContext {
	var p = new(VariableClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableClassDeclaration
	return p
}

func InitEmptyVariableClassDeclarationContext(p *VariableClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_variableClassDeclaration
}

func (*VariableClassDeclarationContext) IsVariableClassDeclarationContext() {}

func NewVariableClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableClassDeclarationContext {
	var p = new(VariableClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_variableClassDeclaration

	return p
}

func (s *VariableClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableClassDeclarationContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *VariableClassDeclarationContext) VariableMultiDeclaration() IVariableMultiDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableMultiDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableMultiDeclarationContext)
}

func (s *VariableClassDeclarationContext) AnnotationList() IAnnotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *VariableClassDeclarationContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *VariableClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterVariableClassDeclaration(s)
	}
}

func (s *VariableClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitVariableClassDeclaration(s)
	}
}

func (s *VariableClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitVariableClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) VariableClassDeclaration() (localctx IVariableClassDeclarationContext) {
	localctx = NewVariableClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, ggwParserRULE_variableClassDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(529)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(528)
			p.AnnotationList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(532)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(531)
			p.AccessModifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__52 {
		{
			p.SetState(534)
			p.Match(ggwParserT__52)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(537)
			p.VariableDeclaration()
		}

	case 2:
		{
			p.SetState(538)
			p.VariableMultiDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWireKindContext is an interface to support dynamic dispatch.
type IWireKindContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsWireKindContext differentiates from other interfaces.
	IsWireKindContext()
}

type WireKindContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWireKindContext() *WireKindContext {
	var p = new(WireKindContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_wireKind
	return p
}

func InitEmptyWireKindContext(p *WireKindContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_wireKind
}

func (*WireKindContext) IsWireKindContext() {}

func NewWireKindContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WireKindContext {
	var p = new(WireKindContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_wireKind

	return p
}

func (s *WireKindContext) GetParser() antlr.Parser { return s.parser }
func (s *WireKindContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WireKindContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WireKindContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterWireKind(s)
	}
}

func (s *WireKindContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitWireKind(s)
	}
}

func (s *WireKindContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitWireKind(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) WireKind() (localctx IWireKindContext) {
	localctx = NewWireKindContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, ggwParserRULE_wireKind)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		_la = p.GetTokenStream().LA(1)

		if !(_la == ggwParserT__53 || _la == ggwParserT__54) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWireDeclarationContext is an interface to support dynamic dispatch.
type IWireDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WireKind() IWireKindContext
	WireAuth() IWireAuthContext
	OnStatement() IOnStatementContext

	// IsWireDeclarationContext differentiates from other interfaces.
	IsWireDeclarationContext()
}

type WireDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWireDeclarationContext() *WireDeclarationContext {
	var p = new(WireDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_wireDeclaration
	return p
}

func InitEmptyWireDeclarationContext(p *WireDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_wireDeclaration
}

func (*WireDeclarationContext) IsWireDeclarationContext() {}

func NewWireDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WireDeclarationContext {
	var p = new(WireDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_wireDeclaration

	return p
}

func (s *WireDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *WireDeclarationContext) WireKind() IWireKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWireKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWireKindContext)
}

func (s *WireDeclarationContext) WireAuth() IWireAuthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWireAuthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWireAuthContext)
}

func (s *WireDeclarationContext) OnStatement() IOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnStatementContext)
}

func (s *WireDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WireDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WireDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterWireDeclaration(s)
	}
}

func (s *WireDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitWireDeclaration(s)
	}
}

func (s *WireDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitWireDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) WireDeclaration() (localctx IWireDeclarationContext) {
	localctx = NewWireDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, ggwParserRULE_wireDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.Match(ggwParserT__55)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__53 || _la == ggwParserT__54 {
		{
			p.SetState(544)
			p.WireKind()
		}

	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__56 {
		{
			p.SetState(547)
			p.WireAuth()
		}

	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(550)
			p.OnStatement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWireAuthContext is an interface to support dynamic dispatch.
type IWireAuthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsWireAuthContext differentiates from other interfaces.
	IsWireAuthContext()
}

type WireAuthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWireAuthContext() *WireAuthContext {
	var p = new(WireAuthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_wireAuth
	return p
}

func InitEmptyWireAuthContext(p *WireAuthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_wireAuth
}

func (*WireAuthContext) IsWireAuthContext() {}

func NewWireAuthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WireAuthContext {
	var p = new(WireAuthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_wireAuth

	return p
}

func (s *WireAuthContext) GetParser() antlr.Parser { return s.parser }

func (s *WireAuthContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(ggwParserSTRING)
}

func (s *WireAuthContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(ggwParserSTRING, i)
}

func (s *WireAuthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WireAuthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WireAuthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterWireAuth(s)
	}
}

func (s *WireAuthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitWireAuth(s)
	}
}

func (s *WireAuthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitWireAuth(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) WireAuth() (localctx IWireAuthContext) {
	localctx = NewWireAuthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, ggwParserRULE_wireAuth)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(ggwParserT__56)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__30 {
		{
			p.SetState(554)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserSTRING:
		{
			p.SetState(557)
			p.Match(ggwParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ggwParserT__19:
		{
			p.SetState(558)
			p.Match(ggwParserT__19)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(559)
			p.Match(ggwParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == ggwParserT__34 {
			{
				p.SetState(560)
				p.Match(ggwParserT__34)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(561)
				p.Match(ggwParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(566)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(567)
			p.Match(ggwParserT__20)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__31 {
		{
			p.SetState(570)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionDeclarationContext is an interface to support dynamic dispatch.
type IFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Block() IBlockContext
	AnnotationList() IAnnotationListContext
	GenericDeclaration() IGenericDeclarationContext
	ArgumentList() IArgumentListContext
	TypeDeclaration() ITypeDeclarationContext
	WireDeclaration() IWireDeclarationContext

	// IsFunctionDeclarationContext differentiates from other interfaces.
	IsFunctionDeclarationContext()
}

type FunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDeclarationContext() *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_functionDeclaration
	return p
}

func InitEmptyFunctionDeclarationContext(p *FunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_functionDeclaration
}

func (*FunctionDeclarationContext) IsFunctionDeclarationContext() {}

func NewFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDeclarationContext {
	var p = new(FunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_functionDeclaration

	return p
}

func (s *FunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *FunctionDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionDeclarationContext) AnnotationList() IAnnotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *FunctionDeclarationContext) GenericDeclaration() IGenericDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDeclarationContext)
}

func (s *FunctionDeclarationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionDeclarationContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *FunctionDeclarationContext) WireDeclaration() IWireDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWireDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWireDeclarationContext)
}

func (s *FunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitFunctionDeclaration(s)
	}
}

func (s *FunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) FunctionDeclaration() (localctx IFunctionDeclarationContext) {
	localctx = NewFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, ggwParserRULE_functionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(574)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(573)
			p.AnnotationList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(576)
		p.Match(ggwParserT__57)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(577)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__8 {
		{
			p.SetState(578)
			p.GenericDeclaration()
		}

	}
	{
		p.SetState(581)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__44 || _la == ggwParserIDENTIFIER {
		{
			p.SetState(582)
			p.ArgumentList()
		}

	}
	{
		p.SetState(585)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__22 {
		{
			p.SetState(586)
			p.TypeDeclaration()
		}

	}
	p.SetState(590)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__55 {
		{
			p.SetState(589)
			p.WireDeclaration()
		}

	}
	{
		p.SetState(592)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionClassDeclarationContext is an interface to support dynamic dispatch.
type IFunctionClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Block() IBlockContext
	AnnotationList() IAnnotationListContext
	AccessModifier() IAccessModifierContext
	GenericDeclaration() IGenericDeclarationContext
	ArgumentList() IArgumentListContext
	TypeDeclaration() ITypeDeclarationContext

	// IsFunctionClassDeclarationContext differentiates from other interfaces.
	IsFunctionClassDeclarationContext()
}

type FunctionClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionClassDeclarationContext() *FunctionClassDeclarationContext {
	var p = new(FunctionClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_functionClassDeclaration
	return p
}

func InitEmptyFunctionClassDeclarationContext(p *FunctionClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_functionClassDeclaration
}

func (*FunctionClassDeclarationContext) IsFunctionClassDeclarationContext() {}

func NewFunctionClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionClassDeclarationContext {
	var p = new(FunctionClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_functionClassDeclaration

	return p
}

func (s *FunctionClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionClassDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *FunctionClassDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *FunctionClassDeclarationContext) AnnotationList() IAnnotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *FunctionClassDeclarationContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *FunctionClassDeclarationContext) GenericDeclaration() IGenericDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDeclarationContext)
}

func (s *FunctionClassDeclarationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *FunctionClassDeclarationContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *FunctionClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterFunctionClassDeclaration(s)
	}
}

func (s *FunctionClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitFunctionClassDeclaration(s)
	}
}

func (s *FunctionClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitFunctionClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) FunctionClassDeclaration() (localctx IFunctionClassDeclarationContext) {
	localctx = NewFunctionClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, ggwParserRULE_functionClassDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(595)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 71, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(594)
			p.AnnotationList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0 {
		{
			p.SetState(597)
			p.AccessModifier()
		}

	}
	p.SetState(601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__52 {
		{
			p.SetState(600)
			p.Match(ggwParserT__52)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(603)
		p.Match(ggwParserT__57)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(604)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__8 {
		{
			p.SetState(605)
			p.GenericDeclaration()
		}

	}
	{
		p.SetState(608)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__44 || _la == ggwParserIDENTIFIER {
		{
			p.SetState(609)
			p.ArgumentList()
		}

	}
	{
		p.SetState(612)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__22 {
		{
			p.SetState(613)
			p.TypeDeclaration()
		}

	}
	{
		p.SetState(616)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnonymousFunctionDeclarationContext is an interface to support dynamic dispatch.
type IAnonymousFunctionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	Expression() IExpressionContext
	ArgumentList() IArgumentListContext
	TypeDeclaration() ITypeDeclarationContext

	// IsAnonymousFunctionDeclarationContext differentiates from other interfaces.
	IsAnonymousFunctionDeclarationContext()
}

type AnonymousFunctionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnonymousFunctionDeclarationContext() *AnonymousFunctionDeclarationContext {
	var p = new(AnonymousFunctionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_anonymousFunctionDeclaration
	return p
}

func InitEmptyAnonymousFunctionDeclarationContext(p *AnonymousFunctionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_anonymousFunctionDeclaration
}

func (*AnonymousFunctionDeclarationContext) IsAnonymousFunctionDeclarationContext() {}

func NewAnonymousFunctionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnonymousFunctionDeclarationContext {
	var p = new(AnonymousFunctionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_anonymousFunctionDeclaration

	return p
}

func (s *AnonymousFunctionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *AnonymousFunctionDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *AnonymousFunctionDeclarationContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AnonymousFunctionDeclarationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *AnonymousFunctionDeclarationContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *AnonymousFunctionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnonymousFunctionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnonymousFunctionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterAnonymousFunctionDeclaration(s)
	}
}

func (s *AnonymousFunctionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitAnonymousFunctionDeclaration(s)
	}
}

func (s *AnonymousFunctionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitAnonymousFunctionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) AnonymousFunctionDeclaration() (localctx IAnonymousFunctionDeclarationContext) {
	localctx = NewAnonymousFunctionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, ggwParserRULE_anonymousFunctionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(618)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__44 || _la == ggwParserIDENTIFIER {
		{
			p.SetState(619)
			p.ArgumentList()
		}

	}
	{
		p.SetState(622)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__22 {
		{
			p.SetState(623)
			p.TypeDeclaration()
		}

	}
	{
		p.SetState(626)
		p.Match(ggwParserT__58)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserT__0:
		{
			p.SetState(627)
			p.Block()
		}

	case ggwParserT__19, ggwParserT__23, ggwParserT__24, ggwParserT__30, ggwParserT__32, ggwParserT__66, ggwParserT__87, ggwParserINT, ggwParserFLOAT, ggwParserBOOL, ggwParserSTRING, ggwParserIDENTIFIER:
		{
			p.SetState(628)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorHeadDeclarationContext is an interface to support dynamic dispatch.
type IConstructorHeadDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArgumentList() IArgumentListContext

	// IsConstructorHeadDeclarationContext differentiates from other interfaces.
	IsConstructorHeadDeclarationContext()
}

type ConstructorHeadDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorHeadDeclarationContext() *ConstructorHeadDeclarationContext {
	var p = new(ConstructorHeadDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_constructorHeadDeclaration
	return p
}

func InitEmptyConstructorHeadDeclarationContext(p *ConstructorHeadDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_constructorHeadDeclaration
}

func (*ConstructorHeadDeclarationContext) IsConstructorHeadDeclarationContext() {}

func NewConstructorHeadDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorHeadDeclarationContext {
	var p = new(ConstructorHeadDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_constructorHeadDeclaration

	return p
}

func (s *ConstructorHeadDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorHeadDeclarationContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *ConstructorHeadDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorHeadDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorHeadDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterConstructorHeadDeclaration(s)
	}
}

func (s *ConstructorHeadDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitConstructorHeadDeclaration(s)
	}
}

func (s *ConstructorHeadDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitConstructorHeadDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ConstructorHeadDeclaration() (localctx IConstructorHeadDeclarationContext) {
	localctx = NewConstructorHeadDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, ggwParserRULE_constructorHeadDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__44 || _la == ggwParserIDENTIFIER {
		{
			p.SetState(632)
			p.ArgumentList()
		}

	}
	{
		p.SetState(635)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstructorFuncDeclarationContext is an interface to support dynamic dispatch.
type IConstructorFuncDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ConstructorHeadDeclaration() IConstructorHeadDeclarationContext
	Block() IBlockContext
	AnnotationList() IAnnotationListContext
	AccessModifier() IAccessModifierContext

	// IsConstructorFuncDeclarationContext differentiates from other interfaces.
	IsConstructorFuncDeclarationContext()
}

type ConstructorFuncDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstructorFuncDeclarationContext() *ConstructorFuncDeclarationContext {
	var p = new(ConstructorFuncDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_constructorFuncDeclaration
	return p
}

func InitEmptyConstructorFuncDeclarationContext(p *ConstructorFuncDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_constructorFuncDeclaration
}

func (*ConstructorFuncDeclarationContext) IsConstructorFuncDeclarationContext() {}

func NewConstructorFuncDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstructorFuncDeclarationContext {
	var p = new(ConstructorFuncDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_constructorFuncDeclaration

	return p
}

func (s *ConstructorFuncDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstructorFuncDeclarationContext) ConstructorHeadDeclaration() IConstructorHeadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorHeadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorHeadDeclarationContext)
}

func (s *ConstructorFuncDeclarationContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ConstructorFuncDeclarationContext) AnnotationList() IAnnotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *ConstructorFuncDeclarationContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ConstructorFuncDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstructorFuncDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstructorFuncDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterConstructorFuncDeclaration(s)
	}
}

func (s *ConstructorFuncDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitConstructorFuncDeclaration(s)
	}
}

func (s *ConstructorFuncDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitConstructorFuncDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ConstructorFuncDeclaration() (localctx IConstructorFuncDeclarationContext) {
	localctx = NewConstructorFuncDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, ggwParserRULE_constructorFuncDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(638)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(637)
			p.AnnotationList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0 {
		{
			p.SetState(640)
			p.AccessModifier()
		}

	}
	{
		p.SetState(643)
		p.Match(ggwParserT__59)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(644)
		p.ConstructorHeadDeclaration()
	}
	{
		p.SetState(645)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumDeclarationContext is an interface to support dynamic dispatch.
type IEnumDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationList() IAnnotationListContext
	IDENTIFIER() antlr.TerminalNode
	ConstructorHeadDeclaration() IConstructorHeadDeclarationContext
	AllEnumProperty() []IEnumPropertyContext
	EnumProperty(i int) IEnumPropertyContext
	AccessModifier() IAccessModifierContext
	AllFunctionClassDeclaration() []IFunctionClassDeclarationContext
	FunctionClassDeclaration(i int) IFunctionClassDeclarationContext

	// IsEnumDeclarationContext differentiates from other interfaces.
	IsEnumDeclarationContext()
}

type EnumDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumDeclarationContext() *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_enumDeclaration
	return p
}

func InitEmptyEnumDeclarationContext(p *EnumDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_enumDeclaration
}

func (*EnumDeclarationContext) IsEnumDeclarationContext() {}

func NewEnumDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumDeclarationContext {
	var p = new(EnumDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_enumDeclaration

	return p
}

func (s *EnumDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumDeclarationContext) AnnotationList() IAnnotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *EnumDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *EnumDeclarationContext) ConstructorHeadDeclaration() IConstructorHeadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorHeadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorHeadDeclarationContext)
}

func (s *EnumDeclarationContext) AllEnumProperty() []IEnumPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnumPropertyContext); ok {
			len++
		}
	}

	tst := make([]IEnumPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnumPropertyContext); ok {
			tst[i] = t.(IEnumPropertyContext)
			i++
		}
	}

	return tst
}

func (s *EnumDeclarationContext) EnumProperty(i int) IEnumPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumPropertyContext)
}

func (s *EnumDeclarationContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *EnumDeclarationContext) AllFunctionClassDeclaration() []IFunctionClassDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFunctionClassDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IFunctionClassDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFunctionClassDeclarationContext); ok {
			tst[i] = t.(IFunctionClassDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *EnumDeclarationContext) FunctionClassDeclaration(i int) IFunctionClassDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionClassDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionClassDeclarationContext)
}

func (s *EnumDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitEnumDeclaration(s)
	}
}

func (s *EnumDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitEnumDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) EnumDeclaration() (localctx IEnumDeclarationContext) {
	localctx = NewEnumDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, ggwParserRULE_enumDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(647)
		p.AnnotationList()
	}
	p.SetState(649)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0 {
		{
			p.SetState(648)
			p.AccessModifier()
		}

	}
	{
		p.SetState(651)
		p.Match(ggwParserT__60)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(652)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.ConstructorHeadDeclaration()
	}
	{
		p.SetState(654)
		p.Match(ggwParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(655)
		p.EnumProperty()
	}
	p.SetState(660)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(656)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(657)
			p.EnumProperty()
		}

		p.SetState(662)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&299278268987604992) != 0 {
		{
			p.SetState(663)
			p.FunctionClassDeclaration()
		}

		p.SetState(668)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(669)
		p.Match(ggwParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEnumPropertyContext is an interface to support dynamic dispatch.
type IEnumPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationList() IAnnotationListContext
	IDENTIFIER() antlr.TerminalNode
	ArgumentPassList() IArgumentPassListContext

	// IsEnumPropertyContext differentiates from other interfaces.
	IsEnumPropertyContext()
}

type EnumPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumPropertyContext() *EnumPropertyContext {
	var p = new(EnumPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_enumProperty
	return p
}

func InitEmptyEnumPropertyContext(p *EnumPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_enumProperty
}

func (*EnumPropertyContext) IsEnumPropertyContext() {}

func NewEnumPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumPropertyContext {
	var p = new(EnumPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_enumProperty

	return p
}

func (s *EnumPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumPropertyContext) AnnotationList() IAnnotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *EnumPropertyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *EnumPropertyContext) ArgumentPassList() IArgumentPassListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentPassListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentPassListContext)
}

func (s *EnumPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterEnumProperty(s)
	}
}

func (s *EnumPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitEnumProperty(s)
	}
}

func (s *EnumPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitEnumProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) EnumProperty() (localctx IEnumPropertyContext) {
	localctx = NewEnumPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, ggwParserRULE_enumProperty)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(671)
		p.AnnotationList()
	}
	{
		p.SetState(672)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__30 {
		{
			p.SetState(673)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&10788798464) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&8323596289) != 0) {
			{
				p.SetState(674)
				p.ArgumentPassList()
			}

		}
		{
			p.SetState(677)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	AccessModifier() IAccessModifierContext
	GenericDeclaration() IGenericDeclarationContext
	InterfaceExtends() IInterfaceExtendsContext
	AllInterfaceBodyDeclaration() []IInterfaceBodyDeclarationContext
	InterfaceBodyDeclaration(i int) IInterfaceBodyDeclarationContext

	// IsInterfaceDeclarationContext differentiates from other interfaces.
	IsInterfaceDeclarationContext()
}

type InterfaceDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceDeclarationContext() *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceDeclaration
	return p
}

func InitEmptyInterfaceDeclarationContext(p *InterfaceDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceDeclaration
}

func (*InterfaceDeclarationContext) IsInterfaceDeclarationContext() {}

func NewInterfaceDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceDeclarationContext {
	var p = new(InterfaceDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_interfaceDeclaration

	return p
}

func (s *InterfaceDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *InterfaceDeclarationContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *InterfaceDeclarationContext) GenericDeclaration() IGenericDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDeclarationContext)
}

func (s *InterfaceDeclarationContext) InterfaceExtends() IInterfaceExtendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceExtendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceExtendsContext)
}

func (s *InterfaceDeclarationContext) AllInterfaceBodyDeclaration() []IInterfaceBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IInterfaceBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			tst[i] = t.(IInterfaceBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceDeclarationContext) InterfaceBodyDeclaration(i int) IInterfaceBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceBodyDeclarationContext)
}

func (s *InterfaceDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitInterfaceDeclaration(s)
	}
}

func (s *InterfaceDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitInterfaceDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) InterfaceDeclaration() (localctx IInterfaceDeclarationContext) {
	localctx = NewInterfaceDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, ggwParserRULE_interfaceDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0 {
		{
			p.SetState(680)
			p.AccessModifier()
		}

	}
	{
		p.SetState(683)
		p.Match(ggwParserT__61)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(684)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__8 {
		{
			p.SetState(685)
			p.GenericDeclaration()
		}

	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__88 {
		{
			p.SetState(688)
			p.InterfaceExtends()
		}

	}
	{
		p.SetState(691)
		p.Match(ggwParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-48)) & ^0x3f) == 0 && ((int64(1)<<(_la-48))&2251799813685279) != 0 {
		{
			p.SetState(692)
			p.InterfaceBodyDeclaration()
		}

		p.SetState(697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(698)
		p.Match(ggwParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceBodyDeclarationContext is an interface to support dynamic dispatch.
type IInterfaceBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InterfaceProperty() IInterfacePropertyContext
	InterfaceFunction() IInterfaceFunctionContext

	// IsInterfaceBodyDeclarationContext differentiates from other interfaces.
	IsInterfaceBodyDeclarationContext()
}

type InterfaceBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceBodyDeclarationContext() *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceBodyDeclaration
	return p
}

func InitEmptyInterfaceBodyDeclarationContext(p *InterfaceBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceBodyDeclaration
}

func (*InterfaceBodyDeclarationContext) IsInterfaceBodyDeclarationContext() {}

func NewInterfaceBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceBodyDeclarationContext {
	var p = new(InterfaceBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_interfaceBodyDeclaration

	return p
}

func (s *InterfaceBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceBodyDeclarationContext) InterfaceProperty() IInterfacePropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfacePropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfacePropertyContext)
}

func (s *InterfaceBodyDeclarationContext) InterfaceFunction() IInterfaceFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceFunctionContext)
}

func (s *InterfaceBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterInterfaceBodyDeclaration(s)
	}
}

func (s *InterfaceBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitInterfaceBodyDeclaration(s)
	}
}

func (s *InterfaceBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitInterfaceBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) InterfaceBodyDeclaration() (localctx IInterfaceBodyDeclarationContext) {
	localctx = NewInterfaceBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, ggwParserRULE_interfaceBodyDeclaration)
	p.SetState(702)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(700)
			p.InterfaceProperty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(701)
			p.InterfaceFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfacePropertyContext is an interface to support dynamic dispatch.
type IInterfacePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	TypeDeclaration() ITypeDeclarationContext
	VariableKind() IVariableKindContext

	// IsInterfacePropertyContext differentiates from other interfaces.
	IsInterfacePropertyContext()
}

type InterfacePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfacePropertyContext() *InterfacePropertyContext {
	var p = new(InterfacePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceProperty
	return p
}

func InitEmptyInterfacePropertyContext(p *InterfacePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceProperty
}

func (*InterfacePropertyContext) IsInterfacePropertyContext() {}

func NewInterfacePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfacePropertyContext {
	var p = new(InterfacePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_interfaceProperty

	return p
}

func (s *InterfacePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfacePropertyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *InterfacePropertyContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *InterfacePropertyContext) VariableKind() IVariableKindContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableKindContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableKindContext)
}

func (s *InterfacePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfacePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfacePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterInterfaceProperty(s)
	}
}

func (s *InterfacePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitInterfaceProperty(s)
	}
}

func (s *InterfacePropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitInterfaceProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) InterfaceProperty() (localctx IInterfacePropertyContext) {
	localctx = NewInterfacePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, ggwParserRULE_interfaceProperty)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8725724278030336) != 0 {
		{
			p.SetState(704)
			p.VariableKind()
		}

	}
	{
		p.SetState(707)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(708)
		p.TypeDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceFunctionContext is an interface to support dynamic dispatch.
type IInterfaceFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	TypeDeclaration() ITypeDeclarationContext
	GenericDeclaration() IGenericDeclarationContext
	ArgumentList() IArgumentListContext

	// IsInterfaceFunctionContext differentiates from other interfaces.
	IsInterfaceFunctionContext()
}

type InterfaceFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceFunctionContext() *InterfaceFunctionContext {
	var p = new(InterfaceFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceFunction
	return p
}

func InitEmptyInterfaceFunctionContext(p *InterfaceFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceFunction
}

func (*InterfaceFunctionContext) IsInterfaceFunctionContext() {}

func NewInterfaceFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceFunctionContext {
	var p = new(InterfaceFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_interfaceFunction

	return p
}

func (s *InterfaceFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceFunctionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *InterfaceFunctionContext) TypeDeclaration() ITypeDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDeclarationContext)
}

func (s *InterfaceFunctionContext) GenericDeclaration() IGenericDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDeclarationContext)
}

func (s *InterfaceFunctionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *InterfaceFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterInterfaceFunction(s)
	}
}

func (s *InterfaceFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitInterfaceFunction(s)
	}
}

func (s *InterfaceFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitInterfaceFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) InterfaceFunction() (localctx IInterfaceFunctionContext) {
	localctx = NewInterfaceFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, ggwParserRULE_interfaceFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__8 {
		{
			p.SetState(711)
			p.GenericDeclaration()
		}

	}
	{
		p.SetState(714)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__44 || _la == ggwParserIDENTIFIER {
		{
			p.SetState(715)
			p.ArgumentList()
		}

	}
	{
		p.SetState(718)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(719)
		p.TypeDeclaration()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassDeclarationContext is an interface to support dynamic dispatch.
type IClassDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AnnotationList() IAnnotationListContext
	IDENTIFIER() antlr.TerminalNode
	AccessModifier() IAccessModifierContext
	GenericDeclaration() IGenericDeclarationContext
	ConstructorHeadDeclaration() IConstructorHeadDeclarationContext
	Extends() IExtendsContext
	Implements() IImplementsContext
	OnStatement() IOnStatementContext
	AllClassBodyDeclaration() []IClassBodyDeclarationContext
	ClassBodyDeclaration(i int) IClassBodyDeclarationContext

	// IsClassDeclarationContext differentiates from other interfaces.
	IsClassDeclarationContext()
}

type ClassDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassDeclarationContext() *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_classDeclaration
	return p
}

func InitEmptyClassDeclarationContext(p *ClassDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_classDeclaration
}

func (*ClassDeclarationContext) IsClassDeclarationContext() {}

func NewClassDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassDeclarationContext {
	var p = new(ClassDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_classDeclaration

	return p
}

func (s *ClassDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassDeclarationContext) AnnotationList() IAnnotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnnotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnnotationListContext)
}

func (s *ClassDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *ClassDeclarationContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ClassDeclarationContext) GenericDeclaration() IGenericDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericDeclarationContext)
}

func (s *ClassDeclarationContext) ConstructorHeadDeclaration() IConstructorHeadDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorHeadDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorHeadDeclarationContext)
}

func (s *ClassDeclarationContext) Extends() IExtendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendsContext)
}

func (s *ClassDeclarationContext) Implements() IImplementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsContext)
}

func (s *ClassDeclarationContext) OnStatement() IOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnStatementContext)
}

func (s *ClassDeclarationContext) AllClassBodyDeclaration() []IClassBodyDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IClassBodyDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassBodyDeclarationContext); ok {
			tst[i] = t.(IClassBodyDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *ClassDeclarationContext) ClassBodyDeclaration(i int) IClassBodyDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassBodyDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassBodyDeclarationContext)
}

func (s *ClassDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitClassDeclaration(s)
	}
}

func (s *ClassDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitClassDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ClassDeclaration() (localctx IClassDeclarationContext) {
	localctx = NewClassDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, ggwParserRULE_classDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.AnnotationList()
	}
	p.SetState(723)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1970324836974592) != 0 {
		{
			p.SetState(722)
			p.AccessModifier()
		}

	}
	{
		p.SetState(725)
		p.Match(ggwParserT__62)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(726)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__8 {
		{
			p.SetState(727)
			p.GenericDeclaration()
		}

	}
	p.SetState(731)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__30 {
		{
			p.SetState(730)
			p.ConstructorHeadDeclaration()
		}

	}
	p.SetState(734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__88 {
		{
			p.SetState(733)
			p.Extends()
		}

	}
	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__89 {
		{
			p.SetState(736)
			p.Implements()
		}

	}
	p.SetState(740)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__35 {
		{
			p.SetState(739)
			p.OnStatement()
		}

	}
	{
		p.SetState(742)
		p.Match(ggwParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(746)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-846887834030702592) != 0) || _la == ggwParserIDENTIFIER {
		{
			p.SetState(743)
			p.ClassBodyDeclaration()
		}

		p.SetState(748)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(749)
		p.Match(ggwParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassBodyDeclarationContext is an interface to support dynamic dispatch.
type IClassBodyDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VariableClassDeclaration() IVariableClassDeclarationContext
	FunctionClassDeclaration() IFunctionClassDeclarationContext
	ConstructorFuncDeclaration() IConstructorFuncDeclarationContext
	ClassDeclaration() IClassDeclarationContext
	InterfaceDeclaration() IInterfaceDeclarationContext
	EnumDeclaration() IEnumDeclarationContext

	// IsClassBodyDeclarationContext differentiates from other interfaces.
	IsClassBodyDeclarationContext()
}

type ClassBodyDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassBodyDeclarationContext() *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_classBodyDeclaration
	return p
}

func InitEmptyClassBodyDeclarationContext(p *ClassBodyDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_classBodyDeclaration
}

func (*ClassBodyDeclarationContext) IsClassBodyDeclarationContext() {}

func NewClassBodyDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassBodyDeclarationContext {
	var p = new(ClassBodyDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_classBodyDeclaration

	return p
}

func (s *ClassBodyDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassBodyDeclarationContext) VariableClassDeclaration() IVariableClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableClassDeclarationContext)
}

func (s *ClassBodyDeclarationContext) FunctionClassDeclaration() IFunctionClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionClassDeclarationContext)
}

func (s *ClassBodyDeclarationContext) ConstructorFuncDeclaration() IConstructorFuncDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstructorFuncDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstructorFuncDeclarationContext)
}

func (s *ClassBodyDeclarationContext) ClassDeclaration() IClassDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassDeclarationContext)
}

func (s *ClassBodyDeclarationContext) InterfaceDeclaration() IInterfaceDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInterfaceDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInterfaceDeclarationContext)
}

func (s *ClassBodyDeclarationContext) EnumDeclaration() IEnumDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnumDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnumDeclarationContext)
}

func (s *ClassBodyDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassBodyDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassBodyDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitClassBodyDeclaration(s)
	}
}

func (s *ClassBodyDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitClassBodyDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ClassBodyDeclaration() (localctx IClassBodyDeclarationContext) {
	localctx = NewClassBodyDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, ggwParserRULE_classBodyDeclaration)
	p.SetState(757)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(751)
			p.VariableClassDeclaration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(752)
			p.FunctionClassDeclaration()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(753)
			p.ConstructorFuncDeclaration()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(754)
			p.ClassDeclaration()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(755)
			p.InterfaceDeclaration()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(756)
			p.EnumDeclaration()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AllBlock() []IBlockContext
	Block(i int) IBlockContext

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_ifStatement
	return p
}

func InitEmptyIfStatementContext(p *IfStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_ifStatement
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IfStatementContext) AllBlock() []IBlockContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBlockContext); ok {
			len++
		}
	}

	tst := make([]IBlockContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBlockContext); ok {
			tst[i] = t.(IBlockContext)
			i++
		}
	}

	return tst
}

func (s *IfStatementContext) Block(i int) IBlockContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) IfStatement() (localctx IIfStatementContext) {
	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, ggwParserRULE_ifStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Match(ggwParserT__63)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(761)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(760)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(763)
		p.Expression()
	}
	p.SetState(765)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__31 {
		{
			p.SetState(764)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(767)
		p.Block()
	}
	p.SetState(780)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__64 {
		{
			p.SetState(768)
			p.Match(ggwParserT__64)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(770)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(769)
				p.Match(ggwParserT__30)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(772)
			p.Expression()
		}
		p.SetState(774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == ggwParserT__31 {
			{
				p.SetState(773)
				p.Match(ggwParserT__31)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(776)
			p.Block()
		}

		p.SetState(782)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__65 {
		{
			p.SetState(783)
			p.Match(ggwParserT__65)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(784)
			p.Block()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenStatementContext is an interface to support dynamic dispatch.
type IWhenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	WhenCaseBlock() IWhenCaseBlockContext
	AllWhenCase() []IWhenCaseContext
	WhenCase(i int) IWhenCaseContext

	// IsWhenStatementContext differentiates from other interfaces.
	IsWhenStatementContext()
}

type WhenStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenStatementContext() *WhenStatementContext {
	var p = new(WhenStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whenStatement
	return p
}

func InitEmptyWhenStatementContext(p *WhenStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whenStatement
}

func (*WhenStatementContext) IsWhenStatementContext() {}

func NewWhenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenStatementContext {
	var p = new(WhenStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_whenStatement

	return p
}

func (s *WhenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenStatementContext) WhenCaseBlock() IWhenCaseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenCaseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenCaseBlockContext)
}

func (s *WhenStatementContext) AllWhenCase() []IWhenCaseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenCaseContext); ok {
			len++
		}
	}

	tst := make([]IWhenCaseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenCaseContext); ok {
			tst[i] = t.(IWhenCaseContext)
			i++
		}
	}

	return tst
}

func (s *WhenStatementContext) WhenCase(i int) IWhenCaseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenCaseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenCaseContext)
}

func (s *WhenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterWhenStatement(s)
	}
}

func (s *WhenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitWhenStatement(s)
	}
}

func (s *WhenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitWhenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) WhenStatement() (localctx IWhenStatementContext) {
	localctx = NewWhenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, ggwParserRULE_whenStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(787)
		p.Match(ggwParserT__66)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(789)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(788)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(791)
		p.Expression()
	}
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__31 {
		{
			p.SetState(792)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(795)
		p.Match(ggwParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&10788798464) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&8323596289) != 0) {
		{
			p.SetState(796)
			p.WhenCase()
		}

		p.SetState(801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

	{
		p.SetState(802)
		p.Match(ggwParserT__65)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(803)
		p.Match(ggwParserT__67)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(804)
		p.WhenCaseBlock()
	}

	{
		p.SetState(806)
		p.Match(ggwParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenCaseContext is an interface to support dynamic dispatch.
type IWhenCaseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	WhenCaseBlock() IWhenCaseBlockContext

	// IsWhenCaseContext differentiates from other interfaces.
	IsWhenCaseContext()
}

type WhenCaseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenCaseContext() *WhenCaseContext {
	var p = new(WhenCaseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whenCase
	return p
}

func InitEmptyWhenCaseContext(p *WhenCaseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whenCase
}

func (*WhenCaseContext) IsWhenCaseContext() {}

func NewWhenCaseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenCaseContext {
	var p = new(WhenCaseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_whenCase

	return p
}

func (s *WhenCaseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenCaseContext) WhenCaseBlock() IWhenCaseBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenCaseBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenCaseBlockContext)
}

func (s *WhenCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenCaseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterWhenCase(s)
	}
}

func (s *WhenCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitWhenCase(s)
	}
}

func (s *WhenCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitWhenCase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) WhenCase() (localctx IWhenCaseContext) {
	localctx = NewWhenCaseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, ggwParserRULE_whenCase)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(808)
		p.Expression()
	}
	{
		p.SetState(809)
		p.Match(ggwParserT__67)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(810)
		p.WhenCaseBlock()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenCaseBlockContext is an interface to support dynamic dispatch.
type IWhenCaseBlockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext
	Expression() IExpressionContext

	// IsWhenCaseBlockContext differentiates from other interfaces.
	IsWhenCaseBlockContext()
}

type WhenCaseBlockContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenCaseBlockContext() *WhenCaseBlockContext {
	var p = new(WhenCaseBlockContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whenCaseBlock
	return p
}

func InitEmptyWhenCaseBlockContext(p *WhenCaseBlockContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whenCaseBlock
}

func (*WhenCaseBlockContext) IsWhenCaseBlockContext() {}

func NewWhenCaseBlockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenCaseBlockContext {
	var p = new(WhenCaseBlockContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_whenCaseBlock

	return p
}

func (s *WhenCaseBlockContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenCaseBlockContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *WhenCaseBlockContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WhenCaseBlockContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenCaseBlockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenCaseBlockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenCaseBlockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterWhenCaseBlock(s)
	}
}

func (s *WhenCaseBlockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitWhenCaseBlock(s)
	}
}

func (s *WhenCaseBlockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitWhenCaseBlock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) WhenCaseBlock() (localctx IWhenCaseBlockContext) {
	localctx = NewWhenCaseBlockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, ggwParserRULE_whenCaseBlock)
	var _la int

	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserT__0:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(812)
			p.Match(ggwParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(816)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-855750919902461832) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&34376657833) != 0) {
			{
				p.SetState(813)
				p.Statement()
			}

			p.SetState(818)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(819)
			p.Match(ggwParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ggwParserT__19, ggwParserT__23, ggwParserT__24, ggwParserT__30, ggwParserT__32, ggwParserT__66, ggwParserT__87, ggwParserINT, ggwParserFLOAT, ggwParserBOOL, ggwParserSTRING, ggwParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(820)
			p.Expression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForStatementContext is an interface to support dynamic dispatch.
type IForStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	VariableDeclaration() IVariableDeclarationContext
	Expression() IExpressionContext
	ForIncrementExpression() IForIncrementExpressionContext

	// IsForStatementContext differentiates from other interfaces.
	IsForStatementContext()
}

type ForStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForStatementContext() *ForStatementContext {
	var p = new(ForStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_forStatement
	return p
}

func InitEmptyForStatementContext(p *ForStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_forStatement
}

func (*ForStatementContext) IsForStatementContext() {}

func NewForStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForStatementContext {
	var p = new(ForStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_forStatement

	return p
}

func (s *ForStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForStatementContext) VariableDeclaration() IVariableDeclarationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableDeclarationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableDeclarationContext)
}

func (s *ForStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForStatementContext) ForIncrementExpression() IForIncrementExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IForIncrementExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IForIncrementExpressionContext)
}

func (s *ForStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterForStatement(s)
	}
}

func (s *ForStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitForStatement(s)
	}
}

func (s *ForStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitForStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ForStatement() (localctx IForStatementContext) {
	localctx = NewForStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, ggwParserRULE_forStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(ggwParserT__68)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 115, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(824)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(828)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&8725726425513984) != 0) || _la == ggwParserIDENTIFIER {
		{
			p.SetState(827)
			p.VariableDeclaration()
		}

	}
	{
		p.SetState(830)
		p.Match(ggwParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&10788798464) != 0) || ((int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&8323596289) != 0) {
		{
			p.SetState(831)
			p.Expression()
		}

	}
	{
		p.SetState(834)
		p.Match(ggwParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__23 || _la == ggwParserT__24 || _la == ggwParserIDENTIFIER {
		{
			p.SetState(835)
			p.ForIncrementExpression()
		}

	}
	p.SetState(839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__31 {
		{
			p.SetState(838)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(841)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForIncrementExpressionContext is an interface to support dynamic dispatch.
type IForIncrementExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsForIncrementExpressionContext differentiates from other interfaces.
	IsForIncrementExpressionContext()
}

type ForIncrementExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForIncrementExpressionContext() *ForIncrementExpressionContext {
	var p = new(ForIncrementExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_forIncrementExpression
	return p
}

func InitEmptyForIncrementExpressionContext(p *ForIncrementExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_forIncrementExpression
}

func (*ForIncrementExpressionContext) IsForIncrementExpressionContext() {}

func NewForIncrementExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForIncrementExpressionContext {
	var p = new(ForIncrementExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_forIncrementExpression

	return p
}

func (s *ForIncrementExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ForIncrementExpressionContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *ForIncrementExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForIncrementExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForIncrementExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForIncrementExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterForIncrementExpression(s)
	}
}

func (s *ForIncrementExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitForIncrementExpression(s)
	}
}

func (s *ForIncrementExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitForIncrementExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ForIncrementExpression() (localctx IForIncrementExpressionContext) {
	localctx = NewForIncrementExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, ggwParserRULE_forIncrementExpression)
	var _la int

	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(843)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(844)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ggwParserT__23 || _la == ggwParserT__24) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(845)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ggwParserT__23 || _la == ggwParserT__24) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(846)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(847)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(848)
			_la = p.GetTokenStream().LA(1)

			if !(_la == ggwParserT__25 || _la == ggwParserT__26) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(849)
			p.Expression()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IForInStatementContext is an interface to support dynamic dispatch.
type IForInStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllVariableName() []IVariableNameContext
	VariableName(i int) IVariableNameContext
	Expression() IExpressionContext
	Block() IBlockContext

	// IsForInStatementContext differentiates from other interfaces.
	IsForInStatementContext()
}

type ForInStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForInStatementContext() *ForInStatementContext {
	var p = new(ForInStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_forInStatement
	return p
}

func InitEmptyForInStatementContext(p *ForInStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_forInStatement
}

func (*ForInStatementContext) IsForInStatementContext() {}

func NewForInStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ForInStatementContext {
	var p = new(ForInStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_forInStatement

	return p
}

func (s *ForInStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ForInStatementContext) AllVariableName() []IVariableNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVariableNameContext); ok {
			len++
		}
	}

	tst := make([]IVariableNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVariableNameContext); ok {
			tst[i] = t.(IVariableNameContext)
			i++
		}
	}

	return tst
}

func (s *ForInStatementContext) VariableName(i int) IVariableNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableNameContext)
}

func (s *ForInStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ForInStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *ForInStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ForInStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ForInStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterForInStatement(s)
	}
}

func (s *ForInStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitForInStatement(s)
	}
}

func (s *ForInStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitForInStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ForInStatement() (localctx IForInStatementContext) {
	localctx = NewForInStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, ggwParserRULE_forInStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.Match(ggwParserT__68)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(854)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(853)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(856)
		p.VariableName()
	}
	p.SetState(861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(857)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(858)
			p.VariableName()
		}

		p.SetState(863)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(864)
		p.Match(ggwParserT__69)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(865)
		p.Expression()
	}
	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__31 {
		{
			p.SetState(866)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(869)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhileStatementContext is an interface to support dynamic dispatch.
type IWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	Block() IBlockContext

	// IsWhileStatementContext differentiates from other interfaces.
	IsWhileStatementContext()
}

type WhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhileStatementContext() *WhileStatementContext {
	var p = new(WhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whileStatement
	return p
}

func InitEmptyWhileStatementContext(p *WhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_whileStatement
}

func (*WhileStatementContext) IsWhileStatementContext() {}

func NewWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhileStatementContext {
	var p = new(WhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_whileStatement

	return p
}

func (s *WhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhileStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *WhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterWhileStatement(s)
	}
}

func (s *WhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitWhileStatement(s)
	}
}

func (s *WhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) WhileStatement() (localctx IWhileStatementContext) {
	localctx = NewWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, ggwParserRULE_whileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		p.Match(ggwParserT__70)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(873)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(872)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(875)
		p.Expression()
	}
	p.SetState(877)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__31 {
		{
			p.SetState(876)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(879)
		p.Block()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDoWhileStatementContext is an interface to support dynamic dispatch.
type IDoWhileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Block() IBlockContext
	Expression() IExpressionContext

	// IsDoWhileStatementContext differentiates from other interfaces.
	IsDoWhileStatementContext()
}

type DoWhileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDoWhileStatementContext() *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_doWhileStatement
	return p
}

func InitEmptyDoWhileStatementContext(p *DoWhileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_doWhileStatement
}

func (*DoWhileStatementContext) IsDoWhileStatementContext() {}

func NewDoWhileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DoWhileStatementContext {
	var p = new(DoWhileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_doWhileStatement

	return p
}

func (s *DoWhileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DoWhileStatementContext) Block() IBlockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContext)
}

func (s *DoWhileStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DoWhileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoWhileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DoWhileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitDoWhileStatement(s)
	}
}

func (s *DoWhileStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitDoWhileStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) DoWhileStatement() (localctx IDoWhileStatementContext) {
	localctx = NewDoWhileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, ggwParserRULE_doWhileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(881)
		p.Match(ggwParserT__71)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(882)
		p.Block()
	}
	{
		p.SetState(883)
		p.Match(ggwParserT__70)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(885)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(884)
			p.Match(ggwParserT__30)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(887)
		p.Expression()
	}
	p.SetState(889)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__31 {
		{
			p.SetState(888)
			p.Match(ggwParserT__31)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantStatementContext is an interface to support dynamic dispatch.
type IGrantStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode

	// IsGrantStatementContext differentiates from other interfaces.
	IsGrantStatementContext()
}

type GrantStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantStatementContext() *GrantStatementContext {
	var p = new(GrantStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantStatement
	return p
}

func InitEmptyGrantStatementContext(p *GrantStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantStatement
}

func (*GrantStatementContext) IsGrantStatementContext() {}

func NewGrantStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantStatementContext {
	var p = new(GrantStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_grantStatement

	return p
}

func (s *GrantStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantStatementContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(ggwParserSTRING)
}

func (s *GrantStatementContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(ggwParserSTRING, i)
}

func (s *GrantStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGrantStatement(s)
	}
}

func (s *GrantStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGrantStatement(s)
	}
}

func (s *GrantStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGrantStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GrantStatement() (localctx IGrantStatementContext) {
	localctx = NewGrantStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, ggwParserRULE_grantStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(891)
		p.Match(ggwParserT__72)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(906)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__73 {
		{
			p.SetState(892)
			p.Match(ggwParserT__73)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case ggwParserSTRING:
			{
				p.SetState(893)
				p.Match(ggwParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case ggwParserT__19:
			{
				p.SetState(894)
				p.Match(ggwParserT__19)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(895)
				p.Match(ggwParserSTRING)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(900)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == ggwParserT__34 {
				{
					p.SetState(896)
					p.Match(ggwParserT__34)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(897)
					p.Match(ggwParserSTRING)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(902)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(903)
				p.Match(ggwParserT__20)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeStatementContext is an interface to support dynamic dispatch.
type IRevokeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ArrayExpression() IArrayExpressionContext

	// IsRevokeStatementContext differentiates from other interfaces.
	IsRevokeStatementContext()
}

type RevokeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeStatementContext() *RevokeStatementContext {
	var p = new(RevokeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_revokeStatement
	return p
}

func InitEmptyRevokeStatementContext(p *RevokeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_revokeStatement
}

func (*RevokeStatementContext) IsRevokeStatementContext() {}

func NewRevokeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeStatementContext {
	var p = new(RevokeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_revokeStatement

	return p
}

func (s *RevokeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeStatementContext) ArrayExpression() IArrayExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayExpressionContext)
}

func (s *RevokeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterRevokeStatement(s)
	}
}

func (s *RevokeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitRevokeStatement(s)
	}
}

func (s *RevokeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitRevokeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) RevokeStatement() (localctx IRevokeStatementContext) {
	localctx = NewRevokeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, ggwParserRULE_revokeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(908)
		p.Match(ggwParserT__74)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(911)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserT__75:
		{
			p.SetState(909)
			p.Match(ggwParserT__75)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case ggwParserT__19:
		{
			p.SetState(910)
			p.ArrayExpression()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantTreeContext is an interface to support dynamic dispatch.
type IGrantTreeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GrantTreeBody() IGrantTreeBodyContext

	// IsGrantTreeContext differentiates from other interfaces.
	IsGrantTreeContext()
}

type GrantTreeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantTreeContext() *GrantTreeContext {
	var p = new(GrantTreeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTree
	return p
}

func InitEmptyGrantTreeContext(p *GrantTreeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTree
}

func (*GrantTreeContext) IsGrantTreeContext() {}

func NewGrantTreeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantTreeContext {
	var p = new(GrantTreeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_grantTree

	return p
}

func (s *GrantTreeContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantTreeContext) GrantTreeBody() IGrantTreeBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantTreeBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantTreeBodyContext)
}

func (s *GrantTreeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTreeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantTreeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGrantTree(s)
	}
}

func (s *GrantTreeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGrantTree(s)
	}
}

func (s *GrantTreeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGrantTree(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GrantTree() (localctx IGrantTreeContext) {
	localctx = NewGrantTreeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, ggwParserRULE_grantTree)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(913)
		p.Match(ggwParserT__76)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(914)
		p.Match(ggwParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(915)
		p.GrantTreeBody()
	}
	{
		p.SetState(916)
		p.Match(ggwParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantTreeBodyContext is an interface to support dynamic dispatch.
type IGrantTreeBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGrantTreeBranch() []IGrantTreeBranchContext
	GrantTreeBranch(i int) IGrantTreeBranchContext

	// IsGrantTreeBodyContext differentiates from other interfaces.
	IsGrantTreeBodyContext()
}

type GrantTreeBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantTreeBodyContext() *GrantTreeBodyContext {
	var p = new(GrantTreeBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTreeBody
	return p
}

func InitEmptyGrantTreeBodyContext(p *GrantTreeBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTreeBody
}

func (*GrantTreeBodyContext) IsGrantTreeBodyContext() {}

func NewGrantTreeBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantTreeBodyContext {
	var p = new(GrantTreeBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_grantTreeBody

	return p
}

func (s *GrantTreeBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantTreeBodyContext) AllGrantTreeBranch() []IGrantTreeBranchContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrantTreeBranchContext); ok {
			len++
		}
	}

	tst := make([]IGrantTreeBranchContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrantTreeBranchContext); ok {
			tst[i] = t.(IGrantTreeBranchContext)
			i++
		}
	}

	return tst
}

func (s *GrantTreeBodyContext) GrantTreeBranch(i int) IGrantTreeBranchContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantTreeBranchContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantTreeBranchContext)
}

func (s *GrantTreeBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTreeBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantTreeBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGrantTreeBody(s)
	}
}

func (s *GrantTreeBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGrantTreeBody(s)
	}
}

func (s *GrantTreeBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGrantTreeBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GrantTreeBody() (localctx IGrantTreeBodyContext) {
	localctx = NewGrantTreeBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, ggwParserRULE_grantTreeBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserSTRING {
		{
			p.SetState(918)
			p.GrantTreeBranch()
		}

		p.SetState(923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantTreeBranchContext is an interface to support dynamic dispatch.
type IGrantTreeBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	ArrayExpression() IArrayExpressionContext
	GrantTreeInheritance() IGrantTreeInheritanceContext

	// IsGrantTreeBranchContext differentiates from other interfaces.
	IsGrantTreeBranchContext()
}

type GrantTreeBranchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantTreeBranchContext() *GrantTreeBranchContext {
	var p = new(GrantTreeBranchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTreeBranch
	return p
}

func InitEmptyGrantTreeBranchContext(p *GrantTreeBranchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTreeBranch
}

func (*GrantTreeBranchContext) IsGrantTreeBranchContext() {}

func NewGrantTreeBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantTreeBranchContext {
	var p = new(GrantTreeBranchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_grantTreeBranch

	return p
}

func (s *GrantTreeBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantTreeBranchContext) STRING() antlr.TerminalNode {
	return s.GetToken(ggwParserSTRING, 0)
}

func (s *GrantTreeBranchContext) ArrayExpression() IArrayExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayExpressionContext)
}

func (s *GrantTreeBranchContext) GrantTreeInheritance() IGrantTreeInheritanceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantTreeInheritanceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantTreeInheritanceContext)
}

func (s *GrantTreeBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTreeBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantTreeBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGrantTreeBranch(s)
	}
}

func (s *GrantTreeBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGrantTreeBranch(s)
	}
}

func (s *GrantTreeBranchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGrantTreeBranch(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GrantTreeBranch() (localctx IGrantTreeBranchContext) {
	localctx = NewGrantTreeBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, ggwParserRULE_grantTreeBranch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		p.Match(ggwParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__78 {
		{
			p.SetState(925)
			p.GrantTreeInheritance()
		}

	}
	{
		p.SetState(928)
		p.Match(ggwParserT__77)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(929)
		p.ArrayExpression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantTreeInheritanceContext is an interface to support dynamic dispatch.
type IGrantTreeInheritanceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSTRING() []antlr.TerminalNode
	STRING(i int) antlr.TerminalNode
	ArrayExpression() IArrayExpressionContext

	// IsGrantTreeInheritanceContext differentiates from other interfaces.
	IsGrantTreeInheritanceContext()
}

type GrantTreeInheritanceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantTreeInheritanceContext() *GrantTreeInheritanceContext {
	var p = new(GrantTreeInheritanceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTreeInheritance
	return p
}

func InitEmptyGrantTreeInheritanceContext(p *GrantTreeInheritanceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_grantTreeInheritance
}

func (*GrantTreeInheritanceContext) IsGrantTreeInheritanceContext() {}

func NewGrantTreeInheritanceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantTreeInheritanceContext {
	var p = new(GrantTreeInheritanceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_grantTreeInheritance

	return p
}

func (s *GrantTreeInheritanceContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantTreeInheritanceContext) AllSTRING() []antlr.TerminalNode {
	return s.GetTokens(ggwParserSTRING)
}

func (s *GrantTreeInheritanceContext) STRING(i int) antlr.TerminalNode {
	return s.GetToken(ggwParserSTRING, i)
}

func (s *GrantTreeInheritanceContext) ArrayExpression() IArrayExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayExpressionContext)
}

func (s *GrantTreeInheritanceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTreeInheritanceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantTreeInheritanceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGrantTreeInheritance(s)
	}
}

func (s *GrantTreeInheritanceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGrantTreeInheritance(s)
	}
}

func (s *GrantTreeInheritanceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGrantTreeInheritance(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GrantTreeInheritance() (localctx IGrantTreeInheritanceContext) {
	localctx = NewGrantTreeInheritanceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, ggwParserRULE_grantTreeInheritance)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(931)
		p.Match(ggwParserT__78)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(932)
		p.Match(ggwParserSTRING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(937)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(933)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(934)
			p.Match(ggwParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(939)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__79 {
		{
			p.SetState(940)
			p.Match(ggwParserT__79)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(941)
			p.ArrayExpression()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionDeclarationContext is an interface to support dynamic dispatch.
type ISessionDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SessionBody() ISessionBodyContext
	IDENTIFIER() antlr.TerminalNode

	// IsSessionDeclarationContext differentiates from other interfaces.
	IsSessionDeclarationContext()
}

type SessionDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionDeclarationContext() *SessionDeclarationContext {
	var p = new(SessionDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_sessionDeclaration
	return p
}

func InitEmptySessionDeclarationContext(p *SessionDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_sessionDeclaration
}

func (*SessionDeclarationContext) IsSessionDeclarationContext() {}

func NewSessionDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionDeclarationContext {
	var p = new(SessionDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_sessionDeclaration

	return p
}

func (s *SessionDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionDeclarationContext) SessionBody() ISessionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionBodyContext)
}

func (s *SessionDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *SessionDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterSessionDeclaration(s)
	}
}

func (s *SessionDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitSessionDeclaration(s)
	}
}

func (s *SessionDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitSessionDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) SessionDeclaration() (localctx ISessionDeclarationContext) {
	localctx = NewSessionDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, ggwParserRULE_sessionDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(944)
		p.Match(ggwParserT__80)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(946)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserIDENTIFIER {
		{
			p.SetState(945)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(948)
		p.Match(ggwParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(949)
		p.SessionBody()
	}
	{
		p.SetState(950)
		p.Match(ggwParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionBodyContext is an interface to support dynamic dispatch.
type ISessionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSessionProperty() []ISessionPropertyContext
	SessionProperty(i int) ISessionPropertyContext

	// IsSessionBodyContext differentiates from other interfaces.
	IsSessionBodyContext()
}

type SessionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionBodyContext() *SessionBodyContext {
	var p = new(SessionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_sessionBody
	return p
}

func InitEmptySessionBodyContext(p *SessionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_sessionBody
}

func (*SessionBodyContext) IsSessionBodyContext() {}

func NewSessionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionBodyContext {
	var p = new(SessionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_sessionBody

	return p
}

func (s *SessionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionBodyContext) AllSessionProperty() []ISessionPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISessionPropertyContext); ok {
			len++
		}
	}

	tst := make([]ISessionPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISessionPropertyContext); ok {
			tst[i] = t.(ISessionPropertyContext)
			i++
		}
	}

	return tst
}

func (s *SessionBodyContext) SessionProperty(i int) ISessionPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISessionPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISessionPropertyContext)
}

func (s *SessionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterSessionBody(s)
	}
}

func (s *SessionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitSessionBody(s)
	}
}

func (s *SessionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitSessionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) SessionBody() (localctx ISessionBodyContext) {
	localctx = NewSessionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, ggwParserRULE_sessionBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserIDENTIFIER {
		{
			p.SetState(952)
			p.SessionProperty()
		}

		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISessionPropertyContext is an interface to support dynamic dispatch.
type ISessionPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSessionPropertyContext differentiates from other interfaces.
	IsSessionPropertyContext()
}

type SessionPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySessionPropertyContext() *SessionPropertyContext {
	var p = new(SessionPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_sessionProperty
	return p
}

func InitEmptySessionPropertyContext(p *SessionPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_sessionProperty
}

func (*SessionPropertyContext) IsSessionPropertyContext() {}

func NewSessionPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SessionPropertyContext {
	var p = new(SessionPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_sessionProperty

	return p
}

func (s *SessionPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *SessionPropertyContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *SessionPropertyContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SessionPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SessionPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SessionPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterSessionProperty(s)
	}
}

func (s *SessionPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitSessionProperty(s)
	}
}

func (s *SessionPropertyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitSessionProperty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) SessionProperty() (localctx ISessionPropertyContext) {
	localctx = NewSessionPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, ggwParserRULE_sessionProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(958)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(959)
		p.Match(ggwParserT__22)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(960)
		p.Expression()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PrimitiveType() IPrimitiveTypeContext
	ArrayType() IArrayTypeContext
	MapType() IMapTypeContext
	TupleType() ITupleTypeContext
	IDENTIFIER() antlr.TerminalNode

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) PrimitiveType() IPrimitiveTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimitiveTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimitiveTypeContext)
}

func (s *TypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeContext) TupleType() ITupleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeContext)
}

func (s *TypeContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitType(s)
	}
}

func (s *TypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, ggwParserRULE_type)
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case ggwParserT__81, ggwParserT__82, ggwParserT__83, ggwParserT__84, ggwParserT__85:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(962)
			p.PrimitiveType()
		}

	case ggwParserT__86:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(963)
			p.ArrayType()
		}

	case ggwParserT__19:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(964)
			p.MapType()
		}

	case ggwParserT__30:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(965)
			p.TupleType()
		}

	case ggwParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(966)
			p.Match(ggwParserIDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimitiveTypeContext is an interface to support dynamic dispatch.
type IPrimitiveTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimitiveTypeContext differentiates from other interfaces.
	IsPrimitiveTypeContext()
}

type PrimitiveTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimitiveTypeContext() *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_primitiveType
	return p
}

func InitEmptyPrimitiveTypeContext(p *PrimitiveTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_primitiveType
}

func (*PrimitiveTypeContext) IsPrimitiveTypeContext() {}

func NewPrimitiveTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimitiveTypeContext {
	var p = new(PrimitiveTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_primitiveType

	return p
}

func (s *PrimitiveTypeContext) GetParser() antlr.Parser { return s.parser }
func (s *PrimitiveTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimitiveTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimitiveTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitPrimitiveType(s)
	}
}

func (s *PrimitiveTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitPrimitiveType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) PrimitiveType() (localctx IPrimitiveTypeContext) {
	localctx = NewPrimitiveTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, ggwParserRULE_primitiveType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(969)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-82)) & ^0x3f) == 0 && ((int64(1)<<(_la-82))&31) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (s *ArrayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitArrayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, ggwParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(971)
		p.Match(ggwParserT__86)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(972)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *MapTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (s *MapTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitMapType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, ggwParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(974)
		p.Match(ggwParserT__19)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(975)
		p.Type_()
	}
	{
		p.SetState(976)
		p.Match(ggwParserT__20)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(977)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleTypeContext is an interface to support dynamic dispatch.
type ITupleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext

	// IsTupleTypeContext differentiates from other interfaces.
	IsTupleTypeContext()
}

type TupleTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeContext() *TupleTypeContext {
	var p = new(TupleTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_tupleType
	return p
}

func InitEmptyTupleTypeContext(p *TupleTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_tupleType
}

func (*TupleTypeContext) IsTupleTypeContext() {}

func NewTupleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeContext {
	var p = new(TupleTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_tupleType

	return p
}

func (s *TupleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TupleTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TupleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterTupleType(s)
	}
}

func (s *TupleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitTupleType(s)
	}
}

func (s *TupleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitTupleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) TupleType() (localctx ITupleTypeContext) {
	localctx = NewTupleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, ggwParserRULE_tupleType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(979)
		p.Match(ggwParserT__30)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(980)
		p.Type_()
	}
	p.SetState(985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(981)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(982)
			p.Type_()
		}

		p.SetState(987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(988)
		p.Match(ggwParserT__31)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericTypeDeclarationContext is an interface to support dynamic dispatch.
type IGenericTypeDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	Extends() IExtendsContext
	Implements() IImplementsContext

	// IsGenericTypeDeclarationContext differentiates from other interfaces.
	IsGenericTypeDeclarationContext()
}

type GenericTypeDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericTypeDeclarationContext() *GenericTypeDeclarationContext {
	var p = new(GenericTypeDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_genericTypeDeclaration
	return p
}

func InitEmptyGenericTypeDeclarationContext(p *GenericTypeDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_genericTypeDeclaration
}

func (*GenericTypeDeclarationContext) IsGenericTypeDeclarationContext() {}

func NewGenericTypeDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericTypeDeclarationContext {
	var p = new(GenericTypeDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_genericTypeDeclaration

	return p
}

func (s *GenericTypeDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericTypeDeclarationContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *GenericTypeDeclarationContext) Extends() IExtendsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtendsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtendsContext)
}

func (s *GenericTypeDeclarationContext) Implements() IImplementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImplementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImplementsContext)
}

func (s *GenericTypeDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericTypeDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericTypeDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGenericTypeDeclaration(s)
	}
}

func (s *GenericTypeDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGenericTypeDeclaration(s)
	}
}

func (s *GenericTypeDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGenericTypeDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GenericTypeDeclaration() (localctx IGenericTypeDeclarationContext) {
	localctx = NewGenericTypeDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, ggwParserRULE_genericTypeDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(990)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__88 {
		{
			p.SetState(991)
			p.Extends()
		}

	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__89 {
		{
			p.SetState(994)
			p.Implements()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericDeclarationContext is an interface to support dynamic dispatch.
type IGenericDeclarationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGenericTypeDeclaration() []IGenericTypeDeclarationContext
	GenericTypeDeclaration(i int) IGenericTypeDeclarationContext

	// IsGenericDeclarationContext differentiates from other interfaces.
	IsGenericDeclarationContext()
}

type GenericDeclarationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericDeclarationContext() *GenericDeclarationContext {
	var p = new(GenericDeclarationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_genericDeclaration
	return p
}

func InitEmptyGenericDeclarationContext(p *GenericDeclarationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_genericDeclaration
}

func (*GenericDeclarationContext) IsGenericDeclarationContext() {}

func NewGenericDeclarationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericDeclarationContext {
	var p = new(GenericDeclarationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_genericDeclaration

	return p
}

func (s *GenericDeclarationContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericDeclarationContext) AllGenericTypeDeclaration() []IGenericTypeDeclarationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGenericTypeDeclarationContext); ok {
			len++
		}
	}

	tst := make([]IGenericTypeDeclarationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGenericTypeDeclarationContext); ok {
			tst[i] = t.(IGenericTypeDeclarationContext)
			i++
		}
	}

	return tst
}

func (s *GenericDeclarationContext) GenericTypeDeclaration(i int) IGenericTypeDeclarationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericTypeDeclarationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericTypeDeclarationContext)
}

func (s *GenericDeclarationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericDeclarationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericDeclarationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGenericDeclaration(s)
	}
}

func (s *GenericDeclarationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGenericDeclaration(s)
	}
}

func (s *GenericDeclarationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGenericDeclaration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GenericDeclaration() (localctx IGenericDeclarationContext) {
	localctx = NewGenericDeclarationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, ggwParserRULE_genericDeclaration)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(ggwParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(998)
		p.GenericTypeDeclaration()
	}
	p.SetState(1003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(999)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1000)
			p.GenericTypeDeclaration()
		}

		p.SetState(1005)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1006)
		p.Match(ggwParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGenericUsageContext is an interface to support dynamic dispatch.
type IGenericUsageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext

	// IsGenericUsageContext differentiates from other interfaces.
	IsGenericUsageContext()
}

type GenericUsageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenericUsageContext() *GenericUsageContext {
	var p = new(GenericUsageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_genericUsage
	return p
}

func InitEmptyGenericUsageContext(p *GenericUsageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_genericUsage
}

func (*GenericUsageContext) IsGenericUsageContext() {}

func NewGenericUsageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenericUsageContext {
	var p = new(GenericUsageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_genericUsage

	return p
}

func (s *GenericUsageContext) GetParser() antlr.Parser { return s.parser }

func (s *GenericUsageContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *GenericUsageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenericUsageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenericUsageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterGenericUsage(s)
	}
}

func (s *GenericUsageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitGenericUsage(s)
	}
}

func (s *GenericUsageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitGenericUsage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) GenericUsage() (localctx IGenericUsageContext) {
	localctx = NewGenericUsageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, ggwParserRULE_genericUsage)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1008)
		p.Match(ggwParserT__8)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1009)
		p.Type_()
	}
	{
		p.SetState(1010)
		p.Match(ggwParserT__10)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierUsageContext is an interface to support dynamic dispatch.
type IIdentifierUsageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	GenericUsage() IGenericUsageContext
	AllIdentifierUsage() []IIdentifierUsageContext
	IdentifierUsage(i int) IIdentifierUsageContext

	// IsIdentifierUsageContext differentiates from other interfaces.
	IsIdentifierUsageContext()
}

type IdentifierUsageContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierUsageContext() *IdentifierUsageContext {
	var p = new(IdentifierUsageContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_identifierUsage
	return p
}

func InitEmptyIdentifierUsageContext(p *IdentifierUsageContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_identifierUsage
}

func (*IdentifierUsageContext) IsIdentifierUsageContext() {}

func NewIdentifierUsageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierUsageContext {
	var p = new(IdentifierUsageContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_identifierUsage

	return p
}

func (s *IdentifierUsageContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierUsageContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(ggwParserIDENTIFIER, 0)
}

func (s *IdentifierUsageContext) GenericUsage() IGenericUsageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenericUsageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenericUsageContext)
}

func (s *IdentifierUsageContext) AllIdentifierUsage() []IIdentifierUsageContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierUsageContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierUsageContext); ok {
			tst[i] = t.(IIdentifierUsageContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierUsageContext) IdentifierUsage(i int) IIdentifierUsageContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierUsageContext)
}

func (s *IdentifierUsageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierUsageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierUsageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterIdentifierUsage(s)
	}
}

func (s *IdentifierUsageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitIdentifierUsage(s)
	}
}

func (s *IdentifierUsageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitIdentifierUsage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) IdentifierUsage() (localctx IIdentifierUsageContext) {
	localctx = NewIdentifierUsageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, ggwParserRULE_identifierUsage)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == ggwParserT__87 {
		{
			p.SetState(1012)
			p.Match(ggwParserT__87)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1015)
		p.Match(ggwParserIDENTIFIER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1017)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 144, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1016)
			p.GenericUsage()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1019)
				p.Match(ggwParserT__33)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1020)
				p.IdentifierUsage()
			}

		}
		p.SetState(1025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 145, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtendsContext is an interface to support dynamic dispatch.
type IExtendsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierUsage() IIdentifierUsageContext

	// IsExtendsContext differentiates from other interfaces.
	IsExtendsContext()
}

type ExtendsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtendsContext() *ExtendsContext {
	var p = new(ExtendsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_extends
	return p
}

func InitEmptyExtendsContext(p *ExtendsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_extends
}

func (*ExtendsContext) IsExtendsContext() {}

func NewExtendsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtendsContext {
	var p = new(ExtendsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_extends

	return p
}

func (s *ExtendsContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtendsContext) IdentifierUsage() IIdentifierUsageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierUsageContext)
}

func (s *ExtendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtendsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterExtends(s)
	}
}

func (s *ExtendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitExtends(s)
	}
}

func (s *ExtendsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitExtends(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Extends() (localctx IExtendsContext) {
	localctx = NewExtendsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, ggwParserRULE_extends)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(ggwParserT__88)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1027)
		p.IdentifierUsage()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInterfaceExtendsContext is an interface to support dynamic dispatch.
type IInterfaceExtendsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierUsage() []IIdentifierUsageContext
	IdentifierUsage(i int) IIdentifierUsageContext

	// IsInterfaceExtendsContext differentiates from other interfaces.
	IsInterfaceExtendsContext()
}

type InterfaceExtendsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterfaceExtendsContext() *InterfaceExtendsContext {
	var p = new(InterfaceExtendsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceExtends
	return p
}

func InitEmptyInterfaceExtendsContext(p *InterfaceExtendsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_interfaceExtends
}

func (*InterfaceExtendsContext) IsInterfaceExtendsContext() {}

func NewInterfaceExtendsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InterfaceExtendsContext {
	var p = new(InterfaceExtendsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_interfaceExtends

	return p
}

func (s *InterfaceExtendsContext) GetParser() antlr.Parser { return s.parser }

func (s *InterfaceExtendsContext) AllIdentifierUsage() []IIdentifierUsageContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierUsageContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierUsageContext); ok {
			tst[i] = t.(IIdentifierUsageContext)
			i++
		}
	}

	return tst
}

func (s *InterfaceExtendsContext) IdentifierUsage(i int) IIdentifierUsageContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierUsageContext)
}

func (s *InterfaceExtendsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InterfaceExtendsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InterfaceExtendsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterInterfaceExtends(s)
	}
}

func (s *InterfaceExtendsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitInterfaceExtends(s)
	}
}

func (s *InterfaceExtendsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitInterfaceExtends(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) InterfaceExtends() (localctx IInterfaceExtendsContext) {
	localctx = NewInterfaceExtendsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, ggwParserRULE_interfaceExtends)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1029)
		p.Match(ggwParserT__88)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1030)
		p.IdentifierUsage()
	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == ggwParserT__34 {
		{
			p.SetState(1031)
			p.Match(ggwParserT__34)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1032)
			p.IdentifierUsage()
		}

		p.SetState(1037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImplementsContext is an interface to support dynamic dispatch.
type IImplementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierUsage() []IIdentifierUsageContext
	IdentifierUsage(i int) IIdentifierUsageContext

	// IsImplementsContext differentiates from other interfaces.
	IsImplementsContext()
}

type ImplementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImplementsContext() *ImplementsContext {
	var p = new(ImplementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_implements
	return p
}

func InitEmptyImplementsContext(p *ImplementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = ggwParserRULE_implements
}

func (*ImplementsContext) IsImplementsContext() {}

func NewImplementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImplementsContext {
	var p = new(ImplementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = ggwParserRULE_implements

	return p
}

func (s *ImplementsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImplementsContext) AllIdentifierUsage() []IIdentifierUsageContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierUsageContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierUsageContext); ok {
			tst[i] = t.(IIdentifierUsageContext)
			i++
		}
	}

	return tst
}

func (s *ImplementsContext) IdentifierUsage(i int) IIdentifierUsageContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierUsageContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierUsageContext)
}

func (s *ImplementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImplementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImplementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.EnterImplements(s)
	}
}

func (s *ImplementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(ggwListener); ok {
		listenerT.ExitImplements(s)
	}
}

func (s *ImplementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case ggwVisitor:
		return t.VisitImplements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *ggwParser) Implements() (localctx IImplementsContext) {
	localctx = NewImplementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, ggwParserRULE_implements)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.Match(ggwParserT__89)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1039)
		p.IdentifierUsage()
	}
	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1040)
				p.Match(ggwParserT__34)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1041)
				p.IdentifierUsage()
			}

		}
		p.SetState(1046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 147, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}
